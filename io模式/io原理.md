## 同步io和异步io
  - 同步io由用户发出，内核或用户线程不断询问数据就绪，就绪后将数据从内核拷贝到用户线程，完成拷贝之前会处于阻塞状态
  - 异步io全过程由内核操作，只有发出io请求这一步由用户发出，所以不会产生线程阻塞

## 5种io模型
  - 阻塞io模型：字面意思
  - 非阻塞io模型：用户线程发出io请求后不断询问内核数据是否准备好，不会阻塞，如果数据没有准备好，用户线程实际上也可以再次请求，但是由于用户线程一直在询问，所以不会交出cpu
  - 多路复用io模型
    - java的nio其实就是多路复用io模型，由一个线程记录io流的状态来管理多个io
    
## 句柄和文件描述符
  - 句柄一般存在与windows系统中，文件描述符存在与linux和unix中
  - 文件句柄可以看作是连接用户和内核文件对象之间的桥梁
  - 文件描述符和文件句柄在windows下其实是同一个东西
  - 句柄和文件描述符的本质不同，下面解释
  - 文件描述符
    - 非负整数 (但是在系统内部其实并不是int类型)，返回的是一个索引，每个进程维护一个文件描述符表
    - 文件描述符指向系统级的一个文件打开表中被打开的文件，这里的文件是一个名为FILE的结构体，文件句柄就是这个FILE结构体中的每一条属性
    - FILE本身的作用也是用于定位文件的，所以可以将句柄的句柄看作文件指针
    - 总之句柄在很多情况下可以认为和文件描述符是同一个东西
    
    ```c
    typedef struct {
      short level;
      unsigned flags;
      char fd;  // 文件描述符
      unsigned char hold;
      short bsize;
      unsigned char *buffer;
      unsigned ar *curp;
      unsigned istemp;
      short token;
    }FILE;
    ```
    
    - 文件句柄中保存了文件对象的i-node引用，i-node保存了文件的各种属性
    - 因此，不同进程中的文件描述符可能指向同一个打开文件表中的对象，而不同的打开文件表中的指针也可能指向i-node表中的同一个文件
    
    ![file_table](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/io%E6%A8%A1%E5%BC%8F/resources/fd-handle-inode.png)
    
    - open:文件描述符的操作，返回的是一个int类型的文件描述符
    - fopen：返回一个文件指针，只想的事FILE结构体，可以看作是带有io缓存的open封装
    
## 零拷贝方法
  - 零拷贝旨在减少用户态io，减少数据拷贝次数
  - 实现方法一般分7种
    - 用户态直接访问硬件存储，不经过内核空间直接拷贝到用户空间，由于直接操作磁盘io，所以会造成大量资源浪费，一般使用异步卸掉cpu和磁盘之间的io速度差异
    - mmap+write：mmap作为linux系统中的一种内存映射文件方法，可以将内核read缓冲区中的地址和用户空间缓冲区的地址进行映射，将内核read缓冲区和应用共享内存，不需要使数据从内核read缓冲区拷贝到用户缓冲区，但是内核read缓冲区鞥然需要将数据写到内核write缓冲区，整个过程会发生4次上下文切换，1次cpu拷贝和2次dma拷贝
    - 
  
