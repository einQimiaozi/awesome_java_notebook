## 物理内存和虚拟内存
  - 由于进程之间共享cpu资源，所以使用虚拟内存为每个进程提供一套单独的内存空间
  - 虚拟内存本身是不连续的，但是在进程看来，虚拟内存的地址是连续的
  - 用户进程申请并访问物理内存（或磁盘存储空间）的过程
    - 用户进程向操作系统发出内存申请请求
    - 系统会检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址
    - 系统为这块虚拟地址创建的内存映射（Memory Mapping），并将它放进该进程的页表（Page Table）
    - 系统返回虚拟地址给用户进程，用户进程开始访问该虚拟地址
    - CPU 根据虚拟地址在此进程的页表（Page Table）中找到了相应的内存映射（Memory Mapping），但是这个内存映射（Memory Mapping）没有和物理内存关联，于是产生缺页中断
    - 操作系统收到缺页中断后，分配真正的物理内存并将它关联到页表相应的内存映射（Memory Mapping）。中断处理完成后 CPU 就可以访问内存了
    - 当然缺页中断不是每次都会发生，只有系统觉得有必要延迟分配内存的时候才用的着，也即很多时候在上面的第 3 步系统会分配真正的物理内存并和内存映射（Memory Mapping）进行关联。
  - 引入虚拟内存的优点
    - 地址空间大且连续(在进程看来)
    - 进程隔离
    - 数据保护
    - 内存映射：可以根据需要将磁盘文件映射到虚拟内存中，提高物理内存利用率
    - 内存共享：可以在内存中的同一份数据
    - 物理地址由操作系统统一管理，进程无法插手，提高内存利用率

##  用户空间
  - 用户空间不能访问内核空间的数据，也不能调用内核空间的函数
  - 用户空间进行系统调用时需要切换到内核态
  - 用户空间的区域
    - 运行时栈：由编译器释放，存放函数的参数，局部变量和返回值等，栈区从高位到低位地址，空间连续
    - 运行时堆：存放进程运行中动态分配的内存段，地址从低到高，不连续，采用同链式结构存储，申请空间时，哭函数按照一定的算法搜索足够大的空间分配，效率比栈空间低
    - 代码段：存放cpu可执行的机器指令，只能读不能写，所有程序共享
    - 数据段：分为未初始化和已初始化，分别存放未初始化的变量和已初始化的变量
    - 内存映射区域：将与你空家你的内存映射到物理空间
    - 允许页面中断
    - x86的cpu下用户空间的寻址范围为0x0.......到0x00007f....，共3g

## 内核空间
  - 内核空间为操作系统的内核保留，分为进程的私有和共享虚拟内存，不允许用户态直接访问
  - 私有虚拟内存：每个进程单独维护自己的内核栈，页表等
  - 共享虚拟内存：所有进程都可以共享，包括内核数据，物理寄存器等
  - 可以访问所有空间
  - 不允许页面中断
  - x86的cpu下内核空间的寻址范围为0xffff880.....到最大地址，共1g

## io中断原理
  - 用户进程向cpu发起read系统调用，读取数据
  - 用户态切换为内核态，阻塞等待数据返回
  - cpu向磁盘发起io请求，将磁盘数据放入磁盘缓冲区
  - 数据准备完成，磁盘向cpu发出io中断
  - cpu收到io中断后将磁盘缓冲区中的数据拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户缓冲区
  - 用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟
  
## DMA(直接内存存取)传输原理
  - DMA技术：支持硬件绕过cpu直接访问主内存
  - 整个数据传输操作在一个 DMA 控制器的控制下进行的。CPU 除了在数据传输开始和结束时做一点处理外（开始和结束时候要做中断处理）
  - 流程
    - 用户进程向 CPU 发起 read 系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回。
    - CPU 在接收到指令以后对 DMA 磁盘控制器发起调度指令。
    - DMA 磁盘控制器对磁盘发起 I/O 请求，将磁盘数据先放入磁盘控制器缓冲区，CPU 全程不参与此过程。
    - 数据读取完成后，DMA 磁盘控制器会接受到磁盘的通知，将数据从磁盘控制器缓冲区拷贝到内核缓冲区。
    - DMA 磁盘控制器向 CPU 发出数据读完的信号，由 CPU 负责将数据从内核缓冲区拷贝到用户缓冲区。
    - 用户进程由内核态切换回用户态，解除阻塞状态，然后等待 CPU 的下一个执行时间钟。

## 同步io和异步io
  - 同步io由用户发出，内核或用户线程不断询问数据就绪，就绪后将数据从内核拷贝到用户线程，完成拷贝之前会处于阻塞状态
  - 异步io全过程由内核操作，只有发出io请求这一步由用户发出，所以不会产生线程阻塞
  
## 零拷贝方法
  - 零拷贝旨在减少用户态io，减少数据拷贝次数
  - 实现方法一般分7种
    - 用户直接io：该方法依然需要切换用户态和内核态，由用户进程直接和硬件做数据交换，只适用于自缓存机制应用，如数据库，缺点是由于cpu和磁盘的io速度差距大，会造成资源浪费，可以使用异步io解决
    - mmap + write：使用mmap将内核缓冲区的地址映射到用户缓冲区，减少了数据从内核缓冲区到用户缓冲区的拷贝，流程如下
      - 用户进程通过 mmap() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
      - 将用户进程的内核空间的读缓冲区（read buffer）与用户空间的缓存区（user buffer）进行内存地址映射。
      - CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
      - 上下文从内核态（kernel space）切换回用户态（user space），mmap 系统调用执行返回。
      - 用户进程通过 write() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
      - CPU将读缓冲区（read buffer）中的数据拷贝到的网络缓冲区（socket buffer）。
      - CPU利用DMA控制器将数据从网络缓冲区（socket buffer）拷贝到网卡进行数据传输。
      - 上下文从内核态（kernel space）切换回用户态（user space），write 系统调用执行返回。


## 5种io模型
  - 阻塞io模型：字面意思
  - 非阻塞io模型：用户线程发出io请求后不断询问内核数据是否准备好，不会阻塞，如果数据没有准备好，用户线程实际上也可以再次请求，但是由于用户线程一直在询问，所以不会交出cpu
  - 多路复用io模型
    - java的nio其实就是多路复用io模型，由一个线程记录io流的状态来管理多个io
    
## 句柄和文件描述符
  - 句柄一般存在与windows系统中，文件描述符存在与linux和unix中
  - 文件句柄可以看作是连接用户和内核文件对象之间的桥梁
  - 文件描述符和文件句柄在windows下其实是同一个东西
  - 句柄和文件描述符的本质不同，下面解释
  - 文件描述符
    - 非负整数 (但是在系统内部其实并不是int类型)，返回的是一个索引，每个进程维护一个文件描述符表
    - 文件描述符指向系统级的一个文件打开表中被打开的文件，这里的文件是一个名为FILE的结构体，文件句柄就是这个FILE结构体中的每一条属性
    - FILE本身的作用也是用于定位文件的，所以可以将句柄的句柄看作文件指针
    - 总之句柄在很多情况下可以认为和文件描述符是同一个东西
    
    ```c
    typedef struct {
      short level;
      unsigned flags;
      char fd;  // 文件描述符
      unsigned char hold;
      short bsize;
      unsigned char *buffer;
      unsigned ar *curp;
      unsigned istemp;
      short token;
    }FILE;
    ```
    
    - 文件句柄中保存了文件对象的i-node引用，i-node保存了文件的各种属性
    - 因此，不同进程中的文件描述符可能指向同一个打开文件表中的对象，而不同的打开文件表中的指针也可能指向i-node表中的同一个文件
    
    ![file_table](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/io%E6%A8%A1%E5%BC%8F/resources/fd-handle-inode.png)
    
    - open:文件描述符的操作，返回的是一个int类型的文件描述符
    - fopen：返回一个文件指针，只想的事FILE结构体，可以看作是带有io缓存的open封装
