## 数组
  - 数组对应的类没有对应的class文件，而是在jvm运行时创建。
  - 数组的类型是以"["开头的，例如int数组->[I,另外多维数组和一维数组是两个类->[I 和 [[I
  - 数组对象的创建是根据jvm指令创建的
    - newarray:创建数组对象
    - multinewarray:创建多个数组对象

## 基本数据类型
  - 关于boolean:jvm中会使用0,1两个int值来表示boolean类型，至于boolean数组则是通过读写btye数组来实现的

  | 类型 | 大小 | 取值范围 | 包装器 |
  | :----: | :----:  | :----: | :----: |
  | byte | 8bit | [-128,+127] | Byte |
  | short | 16bit | [-2^15,+2^15-1] | Short |
  | int | 32bit | [-2^31,+2^31-1] | Integer |
  | long | 64bit | [-2^63,+2^63-1] | Long |
  | float | 32bit | [IEEE754,IEEE754] | Float |
  | double | 64bit | 同上 | Double |
  | char | 16bit |[Unicode 0,Unicode 2^16-1] | Character |
  | void | --- | --- | --- |

## 缓冲池
  - Integer.valueOf(x) 和 new Integer(x) 一个会使用缓存池中的对象(多次调用指向的是同一个对象) 另一个会新建一个对象
  - valueOf(x) 实现的方法就是判断值是否在缓存池中，如果不在就返回，不在就new一个，然后返回。
  
  | 类型 | 缓存范围 |
  | :---: | :---: |
  | boolean | | 所有boolean值 |
  | byte | 所有byte值 |
  | short | -128,127 |
  | int | -128,127 |
  | char | \u0000,\u007F | 
  
  - 在jdk1.8中,integer的缓存池IntegerCache是可以调整缓存范围的，在jvm启动时设置-XX:AutoBoxCacheMax=<size>来设置大小，之后jvm在启动时会生成java.lang.integerCache.high系统属性，通过读取该属性来改变范围。
  
## equals
  - 重写equals时必须重写hashCode方法。
  - Object的hashCode方法视同c语言实现，通过内存地址判断两个变量是否相同，所以当需求变化时，则必须要重写。
  - 一般判断相同需要满足5个性质：
    - 自反性
    - 一致性
    - 传递性
    - 对称性
    - 任何非null对象传入null值结果必为false

## 泛型
  - java的泛型实际上是使用类型擦除实现的伪泛型，所有泛型在编译时会被变成Object，同时也只在编译阶段有效，所以使用时需要强制类型转换
  - 泛型多个不同类型的实例默认指向的是同一个class，而不是不同类型的多个class，这句话慢慢读几遍，有点绕
  - 泛型通配符
    - T E K V 四种，<? super E>必须是E的子类,<? extend E> 必须是E的父类

## String
  - String类被声明为final，不可继承
  - java8中内部使用char数组存储数据，java9中使用byte数组存储，同时使用coder来标识编码类型
  - 线程安全
  
  | 类型 | 可变性 | 线程安全 |
  | :---: | :---: | :---: |
  | String | 不可变 | 安全 |
  | StringBuffer | 可变 | 安全，使用synchronized同步 |
  | StringBuilder | 可变 | 不安全 |
  
  - 不可变性可以用于存储hash值或map中的key
  - String Pool
    - String使用intern()方法返回字符串常量池中的引用
    
    ```java
    String a = new String("a");
    String b = new String("a");
    Systen.out.println(a == b);   // false
    String c = a.intern();
    String d = b.intern();
    System.out.println(c == d); // true
    ```
    
    - 理论上在new String时如果传入的参数不存在于String Pool中，那么会创建两个对象，一个对象引用另一个被放入String Pool中的对象
    - String Pool在堆中
    
