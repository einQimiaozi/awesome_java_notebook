## 概念
- 动态代理简单来说就是允许运行时动态的使用接口创建实例
- 这样做的好处就是JVM创建代理对象时不需要考虑方法的实现，搞一个壳就可以了，方法也不必被方法体限制，可以根据需求动态改动。
- 动态代理实际上是JVM在运行期动态创建class字节码并加载的过程
## 流程
- 由于接口无法new一个实例，所以使用Proxy.newProxyInstance()方法实现。

```java
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DynamicProxy_test {
    public static void main(String[] args) throws Throwable{
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(method);
                if(method.getDeclaringClass().equals("Hello"));
                {
                    if (method.getName().equals("print")) {
                        System.out.println("Hello, " + args[0]);
                    }
                }
                if(method.getDeclaringClass().equals("World"));
                {
                    if (method.getName().equals("print")) {
                        System.out.println("World, " + args[0]);
                    }
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(
                Hello.class.getClassLoader(), // 传入ClassLoader
                new Class[] { Hello.class ,World.class}, // 传入要实现的接口
                handler); // 传入处理调用方法的Invoke重载InvocationHandler
        hello.print("Bob");
    }
}

interface Hello{
    void print(String s);
}

interface World{
    void print(String s);
}
```

运行结果

```
public abstract void Hello.print(java.lang.String)
Hello, Bob
World, Bob
```

- 通过重载InvocationHandler中的invoke方法实现创建类实例并执行方法
- newProxyInstance的参数为ClassLoader，接口的数组(可以传入多个接口)，重载invoke后的InvocationHandler
- 通过代理实现后的Class除了接口自己的方法还继承了Object和代理构造器方法
- invoke方法是代理对象和目标对象之间的桥梁
