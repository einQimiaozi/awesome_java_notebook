- 线程的概念：一个程序里不同的执行路径

## 创建线程的两种方法
  - 1.从Thread类继承
  - 2.实现Runnable接口，重写run方法，该方法需要new Thread(实现的类).start()
  - 3.通过线程池来启动Executors.newCachedThread()
  
## 线程状态
  
  ![Thread1](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91/source/sohucs.jpeg)
  
  - 线程状态全部通过jvm管理
  - 从结束状态无法转移到开始状态，请注意
  - 不要关闭线程，容易产生资源不统一，要让线程自然结束
  - interrupt方法用于打断长时间执行的线程，interrupt本身是异常，需要catch
  
  ```java
  try {
    xxx
  }catch(InterruptedException e) {
    xxx
  }
  ```

## synchronized
  - 多个线程访问同一个资源时使用的锁，被加锁的方法被称为同步方法，锁保资源的原子性，一致性，同步性
  - synchronized锁的本身是其参数中的对象，而不是代码块中的，谁拿到这个对象，就相当于拿到了锁
  - 锁对象可以是基本数据类型以外的类型，不是不允许使用，而是防止其他程序也锁了基本数据类型造成奇怪的结果
  - 锁可以是this，就是当前对象，也完全可以将其写成当前对象的一个方法,相当与传入this做参数
  
  ```java
  public class T {
    private int count = 10;
    
    public synchronized void m() { // 等价与synchronized(this) {xxx}
      xxx
    }
  }
  ```
  
  - 如果给synchronized加入static标志，等价于synchronized(T.class),也就是锁的是该方法所在的类
  - 锁底层的实现就是在需要被锁的对象头像加入两个标志位(0,1)
  - 同步方法和非同步方法是可以同时调用的
  - 加锁的效率会低很多，所以如果业务逻辑允许脏读，则尽量不要加锁
  - 可重入属性：如果一把锁锁了同一个对象，该对象中的同步方法1调用了同步方法2,则该锁允许方法2再次获取这把锁，否则会造成方法1无法调用方法2,形成死锁
  - 异常的锁：程序中出现异常，默认情况下锁会被释放，如果不想释放，手动catch捕获异常让执行继续
  - synchronized实现：
    - 1.首先在锁对象头像使用一个markword记录第一个线程的id(偏向锁)
    - 2.如果有线程争用，升级为自旋锁，第二个线程自旋10次，在用户态解决问题
    - 3.如果10次后第二个线程还拿不到锁，则升级为从操作系统处取用的重量锁，让线程进入等待队列，转为内核态，不占cpu
    - 4.锁只能升级不能降低，当线程只剩一个的时候，依然不会降为偏向锁
    - 5.执行时间长的线程，用重量锁，执行时间短，线程少，用自旋锁

## volatile
  - 保证线程可见性，禁止指令重排序，持续跟踪变量状态变化，变量在某一线程中的副本被更改后会被及时的返回给其他线程
  - 本质上使用了cpu的缓存一致性协议
  - 用于单例模式用的双重检查，如果不加volatile的话，双重检查可能会在指令重排序上出问题
  - 不保证原子性，之保证可见性

## 锁优化
  - 锁粒度变细：争用不是很激烈的时候，尽量锁细化，即如果只需要锁对某个变量的改变起作用，那么要把锁加载代码段上而不是整个方法上
  - 锁粒度变粗：如果某个业务逻辑中锁太多，则不如直接加载方法上，即锁粗化
  - 对象改变：例如锁的对象为 Object o = new Object1(),但是后续代码中不小心class.o = new Object2()，则锁会出问题，所以把对象做锁的时候一定要加上final关键字

## CAS(无锁优化 自旋)
  - 凡是atomic开头的包都是使用CAS保证线程安全的包，例如AtomInteget(线程安全的Integer类)
  - CAS的本质，假设例子中我们希望某个值被线程获取后加1,并且这个操作不会失败
  
  ```java
  void cas(current_val,expected_val,new_val)
  {
    if(current_val == expected_val)
    {
      current_val = new val;
    }
    // 说明这个值被别的线程改了
    else
    {
      cas(++current_val,++expected_val,++new_val);
    }
  } 
  ```
  
  - cas是cpu指令级的原语支持，所以不存在cas方法计算过程中被其他线程改变某些值，上面的代码只是说明原理
  - ABA问题：如果在cas的同时，某个线程把一个值改变后又变回了expected_val，这就是ABA问题，在int类型等基础类型下ABA问题无所谓，在引用类型需要禁止ABA情况的场景下，对cas中加入一个版本号参数，检查版本号即可
  - cas相关操作一般都叫weakCompareAndSetObject(jdk11)

## unsafe
   - 所有的原子操作内部的cas操作都是在unsafe类中完成的
   - 这个类是单例的，不能new
   - 在jdk11之前需要使用反射，在jdk11之后可以直接使用单例访问
   - unsafe可以直接操作内存，通过偏移量定位需要操作的数据，类似c语言malloc的作用，也具有相应的free方法
