- 线程的概念：一个程序里不同的执行路径

## 创建线程的两种方法
  - 1.从Thread类继承
  - 2.实现Runnable接口，重写run方法，该方法需要new Thread(实现的类).start()
  - 3.通过线程池来启动Executors.newCachedThread()
  
## 线程状态
  
  ![Thread1](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E5%B9%B6%E5%8F%91/source/sohucs.jpeg)
  
  - 线程状态全部通过jvm管理
  - 从结束状态无法转移到开始状态，请注意
  - 不要关闭线程，容易产生资源不统一，要让线程自然结束
  - interrupt方法用于打断长时间执行的线程，interrupt本身是异常，需要catch
  
  ```java
  try {
    xxx
  }catch(InterruptedException e) {
    xxx
  }
  ```

## synchronized
  - 多个线程访问同一个资源时使用的锁，被加锁的方法被称为同步方法，锁保资源的原子性，一致性，同步性
  - synchronized锁的本身是其参数中的对象，而不是代码块中的，谁拿到这个对象，就相当于拿到了锁
  - 锁对象可以是基本数据类型以外的类型，不是不允许使用，而是防止其他程序也锁了基本数据类型造成奇怪的结果
  - 锁可以是this，就是当前对象，也完全可以将其写成当前对象的一个方法,相当与传入this做参数
  
  ```java
  public class T {
    private int count = 10;
    
    public synchronized void m() { // 等价与synchronized(this) {xxx}
      xxx
    }
  }
  ```
  
  - 如果给synchronized加入static标志，等价于synchronized(T.class),也就是锁的是该方法所在的类
  - 锁底层的实现就是在需要被锁的对象头像加入两个标志位(0,1)
  - 同步方法和非同步方法是可以同时调用的
  - 加锁的效率会低很多，所以如果业务逻辑允许脏读，则尽量不要加锁
  - 可重入属性：如果一把锁锁了同一个对象，该对象中的同步方法1调用了同步方法2,则该锁允许方法2再次获取这把锁，否则会造成方法1无法调用方法2,形成死锁
  - 异常的锁：程序中出现异常，默认情况下锁会被释放，如果不想释放，手动catch捕获异常让执行继续
  - synchronized实现：
    - 1.首先在锁对象头像使用一个markword记录第一个线程的id(偏向锁)
    - 2.如果有线程争用，升级为自旋锁，第二个线程自旋10次，在用户态解决问题
    - 3.如果10次后第二个线程还拿不到锁，则升级为从操作系统处取用的重量锁，转为内核态，不占cpu
    - 4.锁只能升级不能降低，当线程只剩一个的时候，依然不会降为偏向锁
    - 5.执行时间长的线程，用重量锁，执行时间短，线程少，用自旋锁
  
