## 三种常见的垃圾回收机制

1.标记清除：先标记，标记后统一清除 缺点：执行效率不稳定(回收对象少和多的效率区别巨大)，内存空间容易碎片化

2.标记复制：将内存分成两半(比例不一定是1比1)，一半用完了就开始回收，将没挂的放到另一半上 缺点：内存只能用一半了 优点：内存空间连续了 改进：eden+两个survivor就是这么来的(appel算法)

3.标记整理：每次kill完之后让所有存活对象都移动到内存空间的一端 缺点：移动的时候会停掉其他用户线程(所谓的STW Stop the World)

# 垃圾回收算法 

## 引用计数法

1.每个对象维护一个引用计数器

2.被引用一次计数器+1,引用失效计数器-1

3.计数器归零后对象失效

优点：高效

缺点：需要大量额外空间，无法解决两个对象相互引用的问题(a引用b，b再引用a，这样ab的引用计数器永远至少是大于0的，永远不会被回收)

## 可达性分析算法

1.假设有一个没有失效的对象，叫它GC Roots，从该点进行图遍历，被遍历到的对象就是被引用的对象，那么他们肯定也没有失效

2.没有被遍历到的对象会被标记一次或者直接失效

3.GC Roots的选取：

   - 1.虚拟机栈或本地方法栈中被引用的对象(肯定还活着)
   - 2.方法区中的静态属性和常量属性引用的对象(永生)
   - 3.虚拟机内部的引用，比如基本数据类型对应的class，常驻的一场对象啥的(永生)
   - 4.synchronized所持有的对象(阻塞)
   - 5.本地代码缓存啥的
   - 总结的话就是:永生的，肯定还活着的，阻塞的
   - 另外一些临时性对象也可以加入，还有不同内存区域内的对象也可以，上面五个是肯定可以，而不是只能是五个

4.oopMap
  - oopmap的本质就是一个记录了栈上本地变量到堆上对象的引用关系
  - 其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收
  - oopmap可以不必每次GC的时候都遍历整个GC roots，同时线程除了维护自己的oopmap以外还会将自己的oopmap传给其他线程，这样的作法本质就是以时间换空间

# GC中的常见概念

## 四种引用：
  - 1.强引用：被引用的对象绝不会被回收
  - 2.软引用：在内存溢出前不会被回收。如果内存溢出则回收，如果回收后内存还溢出就抛异常吧
  - 3.弱引用：垃圾收集时直接被回收
  - 4.幻影引用：不光会被直接回收，而且还不能通过引用取得对象实例，这种引用的存在就是在被回收的时候发个通知

## 三色标记
  - 白色：未被访问过的对象，如果可达性分析结束还是白色，则该对象不可达(挂掉)
  - 黑色：被访问过并且存活
  - 灰色：被访问过，但是其指向的引用至少还有一个没被扫描过，是黑色和白色之间的交汇
  
## 引用关系破坏问题
  - 假设对象a引用对象b，对象b引用对象c，那么根据可达性分析算法，abc都为黑色标记
  - 假设GC和用户线程并发执行
  - 现在a被访问后，在访问b的时候如果用户线程删除了b到c的引用，同时让a引用c，那么c会变成白色，并且c本不该是白色，造成误删
  - 解决该问题的方法就是使用写屏障(原始快照，增量更新)

## 安全点
  - 1.oopmap不能对每条指令进行记录，这样消耗太大，所以只有线程在到达安全点的时候才更新oopmap，到达安全点的线程会挂起
  - 2.安全点的选取一般是执行时间较长的代码块，比如循环之类的
  - 3.安全点的线程中断分为两种
    - 1.被动中断：安全点是固定的，每次回收的时候停掉所有在安全点的用户线程，让不在安全点的线程跑到安全点再停掉
    - 2.主动中断：安全点固定，每次回收的时候设置一个标志，不中断任何线程，线程不断轮询标志，如果标志为true，则线程找到离自己最近的安全点再断掉

## 安全区域

  如果用户线程sleep之类的，则没办法自己跑到安全点or轮询，这个时候就用到了安全区，安全区代码要求代码内的引用关系不发生变化，线程执行到安全区代码的时候先标识一下，虚拟机回收垃圾的时候会直接略过安全去代码，出安全区的时候要看根节点枚举是否完成，完成了就直接出，没完成则需要阻塞等待完成才能出

## Stop The World
  - 1.单线程下GC和用户线程只能同时执行一个，所以这时候需要STW
  - 2.并发下为了保证GC中对象的引用关系的一致性，所以需要在GC的时候启动STW，防止出现引用破坏问题
  - 3.stw的实现原理是利用安全点实现的，因为安全点和安全区域可以保证引用关系的一致性，就是所谓的冻结快照，这个时候执行stw是安全的

## 对象的死亡过程

  - 1.被标记后再进行二次筛选，标准是是否执行了finalize()方法
  - 2.如果执行了finalize()方法则系统会像赛跑一样开始追这个对象，这个对象如果在内存回收前执行完finalize()方法则会逃生成功，如果执行的太慢or执行的优先度太低就死掉了
  - 3.finalize()方法只能执行一次，执行第二次就不管用了，对象会直接死掉
  - 4.finalize()这个方法已经不建议使用了，可以使用try+finally代替

# 垃圾回收器

垃圾回收器分为老年代和新生代两种，一个GC的过程中可以使用不同的两个垃圾回收器作为组合回收老年代的新生代的内存区域

## 概念

1.Partial GC：部分收集，仅收集堆中部分区域的垃圾，包含了Young GC(Minor GC)，Old GC(Major GC)和Mixed GC
2.Full GC:对整个java堆和方法区回收

## 分类

| 回收器 | 新生代 | 老年代 | 并发 | 标记清除 | 标记复制 | 标记整理 | STW |
| :----: | :----:  | :----: | :----: | :----: | :----:  | :----: | :----: |
| Serial | O | X | X | X | O | X | O |
| Serial Old | X | O | X | X | X | O | O |
| ParNew | O | X | O | X | O | X | O |
| Parallel Scavenge | O | X | O | X | O | X | O |
| Parallel Old | X | O | O | X | X | O | O |
| CMS | X | O | O | O | X | X | O |
| G1 | O | O | O | X | O | X | O |

## CMS

1.CMS的运行过程
   - 1.初始标记：STW，标记GC Roots能直接关联的对象，速度快
   - 2.并发标记：从GC Roots的直接关联对象开始并发遍历，not STW，速度慢
   - 3.重新标记：修正并发标记期间用户线程运行导致变化的对象关系，STW，速度快，采用卡表+写屏障(增量更新)解决跨代引用和引用关系破坏问题
   - 4.并发清除：kill掉要挂掉的对象，速度快，not STW

2.跨代引用
   - 跨代引用指的是老年代引用年轻代or年轻代引用老年代的问题
   - 假设老年代引用年轻代，则执行Young GC的时候不光要扫描年轻代，还要将老年代全部扫描一次才能确保引用关系不出错，这样消耗太大
   - 可以使用记忆集来解决，将跨代引用记录到一个集合中
   - 跨代引用本质上和引用关系破坏可以放在一起说，因为跨代引用会出问题的部分一般都是老年代引用年轻代，但是老年代出生早与年轻代，所以老年代引用年轻代等同于给黑色对象添加了一个指向白色对象的引用

3.记忆集和卡表
   - 卡表是记忆集的一种实现方式
   - 每个卡表对应一个卡页，通常一个卡页(card)的大小为512字节，卡页的本质就是被且分成一块块大小相同的堆空间
   - 卡表本身是一个简单的数组，每个index指向一个卡页，如果卡页内的引用关系出现变化，则卡表的值将置为dirty
   - jvm中卡表的初始化方法如下(地址右移9位，相当与除512,比如地址的index为0,1,2,则对应的地址就为0,512,1024)
   
   ```java
   CARD_TABLE [this address >> 9] = 0;
   ```
   
   - 通过卡表记录跨代引用，将对应的card位置dirty，就可以不必扫描整个老年代，只扫描dirty找出跨代引用，同时由于跨代引用下的老年代必然不会被回收，所以可以作为GC Roots，使用卡表可以快速定位老年代中的GC Roots

4.写屏障
  - 卡表的dirty则由写屏障触发，写屏障的本质就是在写操作前or写操作后挂上一段逻辑代码
  - 通过并发，如果GC回收时引用关系进行了变化，那么写屏障就会更新卡表，防止出现引用关系破坏问题

5.增量更新和原始快照
  - 这两个方法都是用于解决引用关系破坏问题的，而写屏障则是这两种方法的实现手段，使用写屏障可以在并发环境下实时记录引用关系的变化，并在重新标记阶段再次扫描
  - 增量更新用于CMS中，而原始快照用于G1
  - 增量更新：只要有黑色对象新加了指向白色对象的引用关系，把这个新插入的引用记录下来，等并发扫描结束后，在将这个黑色对象为根重新扫描(本质就是把黑色对象变成灰色对象)
  - 原始快照：当灰色对象删除指向白色对象的引用关系时，就记录这个将要删除的引用，并发扫描结束后，在以白色对象为根重新扫描一次(本质就是把白色对象变成灰色对象)

## G1

G1比其他GC器都要特殊，它同时拥有老年代和新生代的GC，有自己特殊的Mixed GC模式，并且老年代和新生代不再进行物理隔离，而是逻辑上区分

1.G1的数据结构
  - G1不再将对象作为回收单位，而是使用region作为回收单位
  - 一个region是一块内存，region中保存了多个card，card指的就是卡表里那个card，由于card也是一块内存，所以一个card未必仅指一个对象
  - region也被进行了分代，分为新生代和老年代，其中新生代又被分为Eden，Survivor(from)和Survivor(to)，以下简称e，sf和st，他们的比例为8:1:1，老年代除了老年代数据以外，还有Humongous，它用于存储大对象，即容量大于0.5个region的对象
  - region的数量默认为2048个，单个region的大小取值范围为1-32mb
  
  ![G1](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/20200628093617249.png)
 
2.G1的分代模型
   - 1.G1中的Young GC被分为e，st和sf三部分
   - 2.第一次GC的时候会将所有region视为e，被回收掉的e就不管它了，生存下来的e会被标记复制算法放入st中
   - 3.接下来把st中的对象用标记整理算法一定移动到sf中，在sf中的对象内存是连续的，每熬过一次GC就会年长一岁，G1中默认为15岁的对象会被放入老年代，如果sf区域满了，那么同样
   - 4.接下来每次GC循环上面的过程，每次GC后保证e和st为空即可
   - 5.这样做的理由：
      - Survivor的存在是用于解决老年代回收过于频繁的问题，如果没有Survivor，每次幸存对象都会进入老年代，而老年代由于使用标记整理，所以回收速度很慢，而年轻代则快很多 
      - 使用sf专门对幸存对象进行整理可以避免内存碎片问题(为什么使用两个Survivor)

3.G1的回收逻辑
   - G1除了传统的Young GC和Old GC之外还有自己独立MixedGC
   - Mixed GC=YoungGC+部分Old GC，Young GC因为耗费时间短所以肯定会全部执行
   - 具体做法是，对region进行价值排序，回收最大的那些region，至于回收的数量由用户制定一个-XX:MaxGCPauseMills参数，该参数为用户希望的停顿时间，根据衰减均值作为理论基础实现对回收步骤总时间的计算，以此推导出在不超过用户期望时间的情况下最多能回收的region个数

3.rset，cset
   - rset一组map结构的数据结构，k记录了一个region的起始地址，v记录了这个region中一个card在卡表中的位置，每个region会维护一个rset，本质上就是利用这个rset可以得到引用自己的其他region的地址和具体的内存位置，当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况，可以理解为记忆集的另一种实现(反向卡表)
   - cset用于记录要被回收的Region，每次stw的时候都会一次性将cset释放干净，由于rset的存在，所以每次跨代引用只需要扫描cset的region中的rset即可
   - rset每次更新依靠的其实就是写屏障，即引用关系变化或跨代引用的时候会更新，这也是为什么rset能够解决跨代引用和引用关系破坏问题
   - 同一个region之间的引用可以不用rset记录，只有old->young和old->old的关系才需要使用rset记录

4.TAMS
   - TAMS两个指针，用于标记并发回收和并发清除前，region当前最后一个card所在的位置(这个被称top指针)
   - 这样在并发过程中，如果产生新对象，G1要求新对象被分配在tams指向的位置之后，通过tams可以直接得到在并发中产生的新对象，在G1中，并发时产生的新对象被认为是需要存活的

5.G1的Mixed GC运行过程
   - 1.触发条件：eden快满了就触发GC，同时创建cset
   - 2.初始标记：STW，标记GC Roots能直接关联的对象，速度快，同时这一步要修改TAMS指针方便之后的并发标记
   - 3.并发标记：从GC Roots的直接关联对象开始并发遍历，not STW，速度慢，同时这一步启动原始快照记录引用关系变化
   - 4.最终标记：修正并发标记期间用户线程运行导致变化的对象关系，STW，速度快，仅仅对写屏障(原始快照)进行遍历就可以解决引用关系破坏和跨代引用问题
   - 5.筛选标记：根据-XX：MaxGCPauseMills最大化收益，筛选出要回收的region(部分old GC)

6.G1的full GC触发条件：一般当回收速度赶不上内存分配的速度的时候会出发full GC，会导致长时间的stw，cms触发full GC的条件也是如此，比如年轻代晋升老年代失败(G1)，比如由于内存碎片产生浮动垃圾导致Concurrent Mode Failure(cms)
   






