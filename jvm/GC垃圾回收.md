## 三种常见的垃圾回收机制

1.标记清除：先标记，标记后统一清除 缺点：执行效率不稳定(回收对象少和多的效率区别巨大)，内存空间容易碎片化

2.标记复制：将内存分成两半(比例不一定是1比1)，一半用完了就开始回收，将没挂的放到另一半上 缺点：内存只能用一半了 优点：内存空间连续了 改进：eden+两个survivor就是这么来的(appel算法)

3.标记整理：每次kill完之后让所有存活对象都移动到内存空间的一端 缺点：移动的时候会停掉其他用户线程(所谓的STW Stop the World)

# 垃圾回收算法 

## 引用计数法

1.每个对象维护一个引用计数器

2.被引用一次计数器+1,引用失效计数器-1

3.计数器归零后对象失效

优点：高效

缺点：需要大量额外空间，无法解决两个对象相互引用的问题(a引用b，b再引用a，这样ab的引用计数器永远至少是大于0的，永远不会被回收)

## 可达性分析算法

1.假设有一个没有失效的对象，叫它GC Roots，从该点进行图遍历，被遍历到的对象就是被引用的对象，那么他们肯定也没有失效

2.没有被遍历到的对象会被标记一次或者直接失效

3.GC Roots的选取：

   - 1.虚拟机栈或本地方法栈中被引用的对象(肯定还活着)
   - 2.方法区中的静态属性和常量属性引用的对象(永生)
   - 3.虚拟机内部的引用，比如基本数据类型对应的class，常驻的一场对象啥的(永生)
   - 4.synchronized所持有的对象(阻塞)
   - 5.本地代码缓存啥的
   - 总结的话就是:永生的，肯定还活着的，阻塞的
   - 另外一些临时性对象也可以加入，还有不同内存区域内的对象也可以，上面五个是肯定可以，而不是只能是五个

4.oopMap
  - oopmap的本质就是一个记录了栈上本地变量到堆上对象的引用关系
  - 其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收
  - oopmap可以不必每次GC的时候都遍历整个GC roots，同时线程除了维护自己的oopmap以外还会将自己的oopmap传给其他线程，这样的作法本质就是以时间换空间

# GC中的常见概念

## 四种引用：
  - 1.强引用：被引用的对象绝不会被回收
  - 2.软引用：在内存溢出前不会被回收。如果内存溢出则回收，如果回收后内存还溢出就抛异常吧
  - 3.弱引用：垃圾收集时直接被回收
  - 4.幻影引用：不光会被直接回收，而且还不能通过引用取得对象实例，这种引用的存在就是在被回收的时候发个通知

## 三色标记
  - 白色：未被访问过的对象，如果可达性分析结束还是白色，则该对象不可达(挂掉)
  - 黑色：被访问过并且存活
  - 灰色：被访问过，但是其指向的引用至少还有一个没被扫描过，是黑色和白色之间的交汇
  
## 引用关系破坏问题
  - 假设对象a引用对象b，对象b引用对象c，那么根据可达性分析算法，abc都为黑色标记
  - 假设GC和用户线程并发执行
  - 现在a被访问后，在访问b的时候如果用户线程删除了b到c的引用，同时让a引用c，那么c会变成白色，并且c本不该是白色，造成误删
  - 解决该问题的方法就是使用写屏障

## 安全点
  - 1.oopmap不能对每条指令进行记录，这样消耗太大，所以只有线程在到达安全点的时候才更新oopmap，到达安全点的线程会挂起
  - 2.安全点的选取一般是执行时间较长的代码块，比如循环之类的
  - 3.安全点的线程中断分为两种
    - 1.被动中断：安全点是固定的，每次回收的时候停掉所有在安全点的用户线程，让不在安全点的线程跑到安全点再停掉
    - 2.主动中断：安全点固定，每次回收的时候设置一个标志，不中断任何线程，线程不断轮询标志，如果标志为true，则线程找到离自己最近的安全点再断掉

## 安全区域

  如果用户线程sleep之类的，则没办法自己跑到安全点or轮询，这个时候就用到了安全区，安全区代码要求代码内的引用关系不发生变化，线程执行到安全区代码的时候先标识一下，虚拟机回收垃圾的时候会直接略过安全去代码，出安全区的时候要看根节点枚举是否完成，完成了就直接出，没完成则需要阻塞等待完成才能出

## Stop The World
  - 1.单线程下GC和用户线程只能同时执行一个，所以这时候需要STW
  - 2.并发下为了保证GC中对象的引用关系的一致性，所以需要在GC的时候启动STW，防止出现引用破坏问题
  - 3.stw的实现原理是利用安全点实现的，因为安全点和安全区域可以保证引用关系的一致性，就是所谓的冻结快照，这个时候执行stw是安全的

## 对象的死亡过程

  - 1.被标记后再进行二次筛选，标准是是否执行了finalize()方法
  - 2.如果执行了finalize()方法则系统会像赛跑一样开始追这个对象，这个对象如果在内存回收前执行完finalize()方法则会逃生成功，如果执行的太慢or执行的优先度太低就死掉了
  - 3.finalize()方法只能执行一次，执行第二次就不管用了，对象会直接死掉
  - 4.finalize()这个方法已经不建议使用了，可以使用try+finally代替

# 垃圾回收器

垃圾回收器分为老年代和新生代两种，一个GC的过程中可以使用不同的两个垃圾回收器作为组合回收老年代的新生代的内存区域

## 概念

1.Partial GC：部分收集，仅收集堆中部分区域的垃圾，包含了Young GC(Minor GC)，Old GC(Major GC)和Mixed GC
2.Full GC:对整个java堆和方法区回收

## 分类

| 回收器 | 新生代 | 老年代 | 并发 | 标记清除 | 标记复制 | 标记整理 | STW |
| :----: | :----:  | :----: | :----: | :----: | :----:  | :----: | :----: |
| Serial | O | X | X | X | O | X | O |


