## 类的生命周期

![zhouqi](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/zhouqi.png)

其中解析并不是必须在初始化之前执行，这是为了支持java语言运行时的动态绑定特性

## 类加载时机

有且仅有以下六种情况下必须立即对类进行初始化

1.遇到以下字节码指令：new，getstatic(获取静态字段)，putstatic(设置静态字段)，invokestatic(调用静态方法)

2.对未初始化的类反射

3.初始化类时没有初始化其父类时要初始化其父类(这里加载的是父类，仅在父类加载这一时刻上如果子类是在引用父类的静态字段的话，子类是不会同时被初始化的！！)

4.jvm启动时初始化主类

5.jdk7的动态语言支持(四种方法句柄)

6.jdk8中的default关键字修饰的接口方法的实现类如果被初始化，则这个接口要在其之前初始化

另外注意，一个数组被new的时候初始化的不是这个数组的类型，而是数组类本身，比如new int[]，初始化的对象是[int类型而不是int类型

如果遇到某个类型的静态字段被引用，则不会初始化这个类，因为静态字段本质上是被统一存放在NotInitialization的常量池中的

接口初始化时不要求其父类初始化，只有其父接口被使用时才会初始化

## 类加载过程(加载->验证->准备->解析->初始化)

1.加载：需要完成三件事
   - 1.通过一个类的全限定名来获取定义此类的二进制字节流
   - 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
   
   注意：二进制字节流不需要必须从某个class文件中获取
   
   数组本身不通过类加载器创建，是由java虚拟机直接在内存中动态构造的，但是元素类型还是要靠加载器完成加载，并且数组的可访问性和它的元素可访问性一致
   
2.验证：确保class文件的字节流中包含的信息是否符合java虚拟机规范

  - 1.文件格式验证：验证字节流是否符合class文件规范
  - 2.元数据验证：验证字节码描述的信息是否符合java语言规范，就是验证有没有语法错误
  - 3.字节码验证：代码逻辑验证，但是由于代码逻辑这东西很难验证，所以字节码验证通过了也不代表没问题，一般采用StackMapTable存放当前方法体内的所有基本块的本地变量表和操作栈状态，这样可以只检查StackMapTable中的属性是否合法
  - 4.符号引用验证：验证该类是否缺少或不能访问它所依赖的外部方法，类，字段
  
3.准备

该阶段为静态变量和类变量分配内存并初始化，需要注意初始化的时候只包括类变量不包括实例变量，并且初始值是默认值，而不是赋值，比如

```java
public static int value = 123;
```

这里的value实际上在准备阶段的初始值是0,不是123

4.解析

将常量池内的符号引用换成直接引用的过程

注意：对同一个符号引用的解析允许重复多次，但是第一次解析会将结果缓存，也就是说，如果第一次解析成功的话那么之后的解析都将成功，如果第一次解析失败的话之后的解析都将失败，哪怕之后某一次解析实际上成功了也没用

解析的同时也会对字段和方法的可访问性进行检查

以上几点在对invokedynamic指令解析的时候不成立，因为该指令本身就是用于动态语言支持的，也就是说该指令必须要等待程序实际运行的时候才进行解析，这就是之前提到的解析不一定在初始化之前执行的情况了

解析一般包括：
   - 1.对类或接口的解析
   - 2.对字段的解析
   - 3.对方法的解析
   - 4.对接口方法的解析

5.初始化

该阶段将类中的java程序代码主权从虚拟机交给应用程序

该阶段真正执行赋值，等同于执行类构造器<clinit>()方法的过程
   
关于<clinit>():
   
   - 1.由javac编译器自动生成
   - 2.和类的构造函数不同，它保证子类的<clinit>()在父类的<clinit>()后执行(接口除外)，该方法主要是对静态语句块和赋值行为进行处理
   - 3.该方法线程安全，加锁同步
   
## 类加载器

1.类加载器是用于判断两个类是否相等的前提，只有两个相同的类由相同的类加载器加载，两个类相等

2.类加载器的类型：

类加载器全部继承自抽象类java.lang.ClassLoader

   - 1.启动类加载器：由c++实现，是虚拟机的一部分，加载<JAVA_HOME>\lib目录下或被参数-Xbootclasspath指定的目录下的类库
   - 2.其他类型加载器：由java实现，独立在虚拟机之外
      - 扩展类加载器：ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中被java.ext.dirs所指定的路径中的所有类库
      - 应用程序类加载器：AppclassLoader实现，，是ClassLoader类中getSystemClassLoader()方法的返回值，负责加载用户路径(classpath)上的所有类库，可以在代码中直接使用，如果应用程序中没有定义过，则这了就是程序中默认的类加载器
      
3.双亲委派模型
   
   ![](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/weipai.jpg)
   
   双亲委派模型每次在类加载器接到任务的时候都会想父类传送，如果父类处理不了才自己查找后加载，这样的好处就是可以保证类加载器的一致性，即相同的类总是会被相同的类加载器加载

4.破坏双亲委派模型
   - 1.第一次被破坏是因为jdk1.2之前没有双亲委派模型，所以很多自定义类加载器的代码没办法保证类加载器的一致性，解决方法就是在ClassLoader中添加一个findClass方法，让用户自己编写类加载逻辑
   - 2.第二次破坏是由于双亲委派模型不能让父加载器加载子加载器才能访问的类库，所以使用了线程上下文类来解决，类似允许双亲委派模型逆向使用类加载器
   - 3.第三次破坏是为了能够让代码热替换，使用了OSGi提案实现代码热替换，将类加载器模型变成网状结构，破坏了双亲委派模型的结构

  
  


