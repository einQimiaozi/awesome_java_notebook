## 类的生命周期

![zhouqi](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/zhouqi.png)

其中解析并不是必须在初始化之前执行，这是为了支持java语言运行时的动态绑定特性

## 类加载时机

有且仅有以下六种情况下必须立即对类进行初始化

1.遇到以下字节码指令：new，getstatic(获取静态字段)，putstatic(设置静态字段)，invokestatic(调用静态方法)

2.对未初始化的类反射

3.初始化类时没有初始化其父类时要初始化其父类(这里加载的是父类，仅在父类加载这一时刻上如果子类是在引用父类的静态字段的话，子类是不会同时被初始化的！！)

4.jvm启动时初始化主类

5.jdk7的动态语言支持(四种方法句柄)

6.jdk8中的default关键字修饰的接口方法的实现类如果被初始化，则这个接口要在其之前初始化

另外注意，一个数组被new的时候初始化的不是这个数组的类型，而是数组类本身，比如new int[]，初始化的对象是[int类型而不是int类型

如果遇到某个类型的静态字段被引用，则不会初始化这个类，因为静态字段本质上是被统一存放在NotInitialization的常量池中的

接口初始化时不要求其父类初始化，只有其父接口被使用时才会初始化

## 类加载过程(加载->验证->准备->解析)

1.加载：需要完成三件事
   - 1.通过一个类的全限定名来获取定义此类的二进制字节流
   - 2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
   
   注意：二进制字节流不需要必须从某个class文件中获取
   
   数组本身不通过类加载器创建，是由java虚拟机直接在内存中动态构造的，但是元素类型还是要靠加载器完成加载，并且数组的可访问性和它的元素可访问性一致
   
2.验证：确保class文件的字节流中包含的信息是否符合java虚拟机规范

  - 1.文件格式验证：验证字节流是否符合class文件规范
  - 2.元数据验证：验证字节码描述的信息是否符合java语言规范，就是验证有没有语法错误
  - 3.字节码验证：代码逻辑验证，但是由于代码逻辑这东西很难验证，所以字节码验证通过了也不代表没问题，一般采用StackMapTable存放当前方法体内的所有基本块的本地变量表和操作栈状态，这样可以只检查StackMapTable中的属性是否合法
  - 4.符号引用验证：验证该类是否缺少或不能访问它所依赖的外部方法，类，字段
  
  


