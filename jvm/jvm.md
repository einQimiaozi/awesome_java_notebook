## 前置知识：

java方法和本地方法的区别：java方法是由由java语言编写，编译成字节码，存储在class文件中的。java方法是与平台无关的。本地方法是由其他语言（如C、C++ 或其他汇编语言）编写，编译成和处理器相关的代码。本地方法保存在动态连接库中，格式是各个平台专用的，运行中的java程序调用本地方法时，虚拟机装载包含这个本地方法的动态库，并调用这个方法。

## jvm的几个部分

1.类加载器：在jvm启动时或类运行时将class文件加载到jvm中

2.执行引擎：执行class中的字节码指令。jvm中的cpu

3.将内存划分为若干个运行时数据区以模拟实际机器上的存储，记录和调用功能模块，如物理机寄存器和指针记录器等

4.本地方法调用：调用c c++实现的本地方法的代码返回结果

## 运行时数据区

1.程序计数器：
  - 当前线程所执行的字节码的行号指示器，控制字节码执行流程
  - 每个线程计数器独立，线程私有(jvm虚拟机的多线程靠轮流执行来实现，并不是真正的多个线程同时执行)
  - 如果一个线程执行的是本地方法，那么计数器指针会为空。
  - 该区域不会包OutOfMemoryError错误

2.虚拟机栈：
  - 线程私有的java方法(注意是方法，方法，方法)线程内存模型的描述，生命周期和所属线程相同
  - 流程如下：每个方法执行的时候栈内会创建一个栈帧，存储方法内的所有信息(局部变量啥的)，方法调用完毕后出栈
  
3.本地方法栈
  - 大体和虚拟机栈一样，不过调用的是本地方法
  
4.java堆
  - 使用-xms参数设置大小
  - 存放的是对象的实例和数组
  - 由GC堆管理
  - 物理空间不连续，逻辑空间连续
  - 所有线程共享，但是可以划分出私有缓冲区(TLAB)

5.方法区
  - 用于存放已被虚拟机加载的信息，如常量，静态变量，被编译后的代码等
  - 线程共享
  - 同堆一样的空间连续性和容量可变，同时可以选择不实现GC
  - 运行时常量池也是方法区的一部分
  
## 类加载过程

1.找到class文件并把这个文件包含的字节码加载到内存里

2.字节码验证

3.class类数据结构分析并分配相应的内存

4.符号表链接

5.类中的静态属性初始化，静态块执行

## 类加载时机

类的整个加载过程包括三部分，加载，链接，初始化，顺序不能错，类加载时机只有以下几种

1.new、getstatic、putstatic或者invokestatic字节码指令，能生成这四条指令的场景有
  - new实例化对象
  - get/set一个类型的static字段(被final修饰除外)
  - 调用static方法
  
2.对类进行反射调用

3.若初始化的类继承有父类，且父类还未被初始化，则父类必须先被初始化

4.当虚拟机启动时，虚拟机会首先初始化带有main方法的类，即主类； 

5.jdk1.7的动态语言支持

6.jdk1.8中的接口default方法，如果实现类发生初始化，则接口要提前初始化
  
## 对象的创建

  1.new的时候先查常量池里找对应类的符号引用以及是否被加载解析和初始化，没有再创建(类加载)
  
  2.
