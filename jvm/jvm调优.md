## 年轻代大小选择

1.响应时间优先的场景：尽可能将年轻代设大，让应用响应时间尽可能接近系统的最低响应时间限制，这样年轻代GC发生的频率最小

2.吞吐量优先的场景：尽可能设置大，因为对响应时间没有要求，GC可以并行进行，适合8核cpu以上的应用

## 老年代大小的选择：

1.响应时间优先的场景：老年代使用并发GC，设置要考虑并发会话率和会话持续时间等参数，堆太大回收慢，堆太小内存碎片多，一般参考以下原则优化

  - 1.并发垃圾收集信息
  - 2.持久代并发收集次数
  - 3.传统GC信息
  - 4.花费在年轻代和老年代GC上的时间比例
  
  一般减少年轻代和老年代花费时间会提高应用效率
  
2.吞吐量优先的场景：老年代设置小，年轻代设置大，这样可以尽可能回收掉大部分短期对象，老年代存放的都是需要长期存活的对象

## OOM解决办法：
  - 先检查内存是否泄漏，如果泄漏，找到GC Roots泄漏的路径解决
  - 设置-Xms -Xmx加大两个堆
  - 检查堆中是否有对象实例一直没有释放
  - 让-Xms=Xmx，减少内存扩展的开销
  
## 堆空间不足的原因

  - 吞吐量增加
  - 程序无意中保存了对象引用，无法被GC回收
  - 过度使用finalizer
  - 解决方法：-xmx增加堆大小or修复程序中的内存泄漏
  
## GC开销超过限制

   --Xmx
   - 使用-XX：-UseGVOverheadLimit取消GC开销限制
   - 修复程序中的内存泄漏
   
## 请求数组大小超过虚拟机限制

  - Xmx(万物皆可Xmx)
  - 修复程序中分配巨大数组的bug

## 永久代空间不足

   - XX：MaxPermsize增加永久代大小
   - 重启jvm
   
## Metaspace不足

  - 设置-XXMaxMetaSpaceSize增加metaspace大小
  - 为服务器分配更多内存
  - 修复可能的程序bug
  
## 无法新建本机线程

  一般是内存不足造成的
  
  - 为机器分配更多内存
  - 减少java堆空间
  - 修复内存泄漏
  - 增加操作系统级别的限制
  
## 误杀进程或子进程

   一般也是因为内存不足
   
   - 将进程迁移到其他机器上
   - 给机器增加内存
  


  

   
