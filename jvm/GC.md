# 垃圾回收算法

## 引用计数法

1.每个对象维护一个引用计数器

2.被引用一次计数器+1,引用失效计数器-1

3.计数器归零后对象失效

优点：高效

缺点：需要大量额外空间，无法解决两个对象相互引用的问题(a引用b，b再引用a，这样ab的引用计数器永远至少是大于0的，永远不会被回收)

## 可达性分析算法

1.假设有一个没有失效的对象，叫它GC Roots，从该点进行图遍历，被遍历到的对象就是被引用的对象，那么他们肯定也没有失效

2.没有被遍历到的对象会被标记一次或者直接失效

3.GC Roots的选取：

   - 1.虚拟机栈或本地方法栈中被引用的对象(肯定还活着)
   - 2.方法区中的静态属性和常量属性引用的对象(永生)
   - 3.虚拟机内部的引用，比如基本数据类型对应的class，常驻的一场对象啥的(永生)
   - 4.synchronized所持有的对象(阻塞)
   - 5.本地代码缓存啥的
   - 总结的话就是:永生的，肯定还活着的，阻塞的
   - 另外一些临时性对象也可以加入，还有不同内存区域内的对象也可以，上面五个是肯定可以，而不是只能是五个
   
4.四种引用：

  - 1.强引用：被引用的对象绝不会被回收
  - 2.软引用：在内存溢出前不会被回收。如果内存溢出则回收，如果回收后内存还溢出就抛异常吧
  - 3.弱引用：垃圾收集时直接被回收
  - 4.幻影引用：不光会被直接回收，而且还不能通过引用取得对象实例，这种引用的存在就是在被回收的时候发个通知
  
5.死亡过程

前面说过没有被遍历到的对象可能不会直接死亡而被标记

  - 1.被标记后再进行二次筛选，标准是是否执行了finalize()方法
  - 2.如果执行了finalize()方法则系统会像赛跑一样开始追这个对象，这个对象如果在内存回收前执行完finalize()方法则会逃生成功，如果执行的太慢or执行的优先度太低就死掉了
  - 3.finalize()方法只能执行一次，执行第二次就不管用了，对象会直接死掉
  - 4.finalize()这个方法已经不建议使用了，可以使用try+finally代替
  
6.方法区的回收

  - 1.方法区主要回收的就是废弃的常量和不再使用的类型
  - 2.判断类型是否被废弃的标准：1.该类的所有实例都挂了 2.该类的类加载器也挂了 3.该类的类型对象没有再被引用了 4.无法从任何地方反射获取该类的方法
  - 3.满足上述条件的类型可以被回收，但是不是必须回收
  
## 垃圾收集算法大类

jvm中的垃圾收集算法基本都基于分代收集，分代收集用白话说就是将内存中的对象根据其存在的时间分为新生代，老年代和永久代，新生代时间长了变成老年代，老年代时间长了就被标记然后挂掉

其中会出现跨代引用，就是老年代引用新生代or反过来，这样的引用不好处理，但是出现概率很低，为了这部分每次kill对象的时候扫描一下全部老年代不太值，一般是在新生代上家里一块全局数据结构(记忆集)

用记忆集记录那有跨代引用的内存区域，扫描的时候只扫这部分就行

分代收集中最基本的三大类算法就是标记清除和标记复制和标记整理

   - 1.标记清除：先标记，标记后统一清除 缺点：执行效率不稳定(回收对象少和多的效率区别巨大)，内存空间容易碎片化
   - 2.标记复制：将内存分成两半(比例不一定是1比1)，一半用完了就开始回收，将没挂的放到另一半上 缺点：内存只能用一半了 优点：内存空间连续了 改进：eden+两个survivor就是这么来的(appel算法)
   - 3.标记整理：每次kill完之后让所有存活对象都移动到内存空间的一端 缺点：移动的时候会停掉其他用户线程(所谓的STW Stop the World)
   
   
## 算法细节

1.根节点枚举：需要STW，但是根节点枚举耗时比较长，所以停的时间长，一般使用OopMap记录根节点记录对象内什么偏移量上是什么类型，达到快速查找根节点的目的(因为有些类型根本做不了根节点嘛)
   - 关于oopmap: oopmap的本质就是一个记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收

2.安全点：给每一条指令都生成OopMap信息消耗太大，使用安全点在特定指令处生成当前线程(一个线程对应的其实是一个java栈)的OopMap信息，并扫描其他线程，将其他线程的oopmap信息和自己的oopmap信息更新到自己的oopmap中(空间换时间)，一般选择的都是能让程序长时间执行的地方，比如方法调用，循环啥的
   - 1.被动中断：安全点是固定的，每次回收的时候停掉所有在安全点的用户线程，让不在安全点的线程跑到安全点再停掉
   - 2.主动中断：安全点固定，每次回收的时候设置一个标志，不中断任何线程，线程不断轮询标志，如果标志为true，则线程找到离自己最近的安全点再断掉
   
3.安全区域：如果用户线程sleep之类的，则没办法自己跑到安全点or轮询，这个时候就用到了安全区，安全区代码要求代码内的引用关系不发生变化，线程执行到安全区代码的时候先标识一下，虚拟机回收垃圾的时候会直接略过安全去代码，出安全区的时候要看根节点枚举是否完成，完成了就直接出，没完成则需要阻塞等待完成才能出

4.记忆表和卡表：

   - 1.记忆表：记录从非回收区指向回收区的指针的集合，用于高效解决跨代引用问题，只是一种概念，一般靠卡表实现
   - 2.卡表：记忆表的卡精度实现，最小单位是一块内存区域，一般大小为512字节
   - 3.一般卡页内有跨代指针，则对应的卡表就变脏(标志位置为1)
   
5.写屏障：

   - 1.简单来说，这东西就是在对引用进行写操作之前or之后挂上一小段逻辑代码
   - 2.写之前叫写前屏障，写之后叫写后屏障，G1收集器之前只用到过写后屏障
   - 3.写后屏障主要用于更新卡表，让卡表变脏用的，具体案例：
      - CMS收集器中有可能会漏标，比如a引用b，b引用c，此时如果GC，abc都不会被回收
      - 当我们遍历完a，开始遍历b，此时由于cms的并发机制，有可能程序会切断b引用c，使得a引用c
      - 这样c其实还是不能被回收的，但是遍历b的时候会发现c不可达，而虽然c被a引用，但是a已经check过了，所以此时的c就会变成一个不可达点，但是c并不应该被回收
      - 如果使用写屏障的话，可以在a引用c之后将c直接标记为可达对象，防止漏标，也不需要每次修改引用关系都重新扫描一遍整个GC roots

6.可达性分析和三色标记

   - 1.为了让STW尽可能短，可以让用户线程和回收器并发执行
   - 2.问题就是这样执行会使得回收的同时产生新的垃圾or被回收的对象可能同时被用户线程再次引用
   - 3.三色标记用于表示这个问题
      - 白色：未被访问过的对象，如果可达性分析结束还是白色，则该对象不可达(挂掉)
      - 黑色：被访问过并且存活
      - 灰色：被访问过，但是其指向的引用至少还有一个没被扫描过，是黑色和白色之间的交汇
   - 4.问题2出现的条件比如满足:线程插入了一条黑色到白色的新引用，然后删除了全部灰色到白色的引用。所以只要打破两条中的一条就可以解决问提2(让用户线程和回收器并发执行)
   - 5.增量更新：第一次并发回收的同时记录黑色->白色的引用关系，结束后再次扫描被记录的黑色对象
   - 6.原始快照：第一次并发回收的同时记录灰色->白色的引用关系的删除，结束后再次扫描被记录的灰色对象
   - 7.增量更新和原始快照用于打破4中的两个条件
   
## 垃圾回收器

回收器是可以通过老年代和新生代组合的！！！并不是只能一个回收器同时管老年代和新生代

1.Serial收集器：单线程，STW，新生代收集:复制 老年代版本收集：标记整理 内存占用小，适合微服务

2.ParNew：多线程版本的Serial

3.Parallel Scavenge：目标是控制吞吐量，多线程，基于标记-复制

4.CMS：目标是停顿时间最短，基于标记-清除算法，运行过程分为四个步骤
   - 1.初始标记：STW，标记GC Roots能直接关联的对象，速度快
   - 2.并发标记：从GC Roots的直接关联对象开始并发遍历，not STW，速度慢
   - 3.重新标记：修正并发标记期间用户线程运行导致变化的对象关系(就是可达性分析的问题4的解决)，STW，速度快
   - 4.并发清除：kill掉要挂掉的对象，速度快，not STW
   
   缺点：
      - 因为占用了一部分线程导致应用程序变慢
      - 并发清除阶段用户线程还是会乱搞，所以会造成浮动垃圾，只能下次回收了
      - 同样由于并发清除要占用内存，所以要留一部分内存给程序运行，于是CMS不能像其他收集器一样等待老年代内存满了再收集
      - 会产生空间碎片，需要设置参数决定CMS回收n次后，在n+1次时执行空间碎片整理，但是这个过程是STW的，所以需要停顿
      
5.G1收集器：面向服务端应用的垃圾收集器，并行，基于标记-复制算法，和CMS一样拥有四个步骤

![G1](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/20200628093617249.png)

G1将内存区域分为三种颜色的n块区域，每个区域的大小范围在1-32M之间，应为2的n次幂

对于超过单块区域容量大小的对象专门被放在N个连续内存的humongous块中，作为老年代的一部分

老年代和新生代不再是位置固定，而是分散在不连续的内存中，区域作为最小回收单元

回收策略通过判断每个区域的回收价值进行排序筛选

停顿时间可由用户设置，可预测

回收算法：
   - 1.初始标记(STW)：同CMS
   - 2.并发标记：同CMS
   - 3.最终标记(STW)：同CMS
   - 4.清理(STW)：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。整个清理过程使用的是复制算法
   
对于打算从CMS或者ParallelOld收集器迁移过来的应用，按照官方 的建议，如果发现符合如下特征，可以考虑更换成G1收集器以追求更佳性能：

   - 实时数据占用了超过半数的堆空间
   - 对象分配率或“晋升”的速度变化明显
   - 期望消除耗时较长的GC或停顿（超过0.5——1秒）
   
## GC常见模式说明
   
1.Young GC

![Young](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/YoungGc.jpg)

Young GC 回收的是所有年轻代的Region。当E区不能再分配新的对象时就会触发。E区的对象会移动到S区，当S区空间不够的时候，E区的对象会直接晋升到O区，同时S区的数据移动到新的S区，如果S区的部分对象到达一定年龄，会晋升到O区。

2.Mixed GC

![Mixed](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/MixedGc.jpg)

回收所有的年轻代的Region+部分老年代的Region。

使用参数来控制老年代占整个堆的占比，超过这个值就回收

至于为什么是部分老年代，是为了保证停顿时间，通过参数设置停顿时间，如果可能超过这个时间就对当前老年代进行价值排序，优先回收价值高并不超时的部分

3.Full GC

G1的垃圾回收过程是和应用程序并发执行的，当Mixed GC的速度赶不上应用程序申请内存的速度的时候，Mixed G1就会降级到Full GC，收集整个堆

Full GC使用的是Serial GC。Full GC会导致长时间的STW，Major GC通常是跟full GC是等价的

## 关于GC模式的补充整理

Partial GC：并不收集整个GC堆的模式

Young GC：只收集young gen的GC，也叫MinorGC

Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式

Major GC：有时候指full Gc，有时候指Old GC

Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式

Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

1.Serial GC算法：Serial Young GC ＋ Serial Old GC (敲黑板！敲黑板！敲黑板！实际上它是全局范围的Full GC)

2.Parallel GC算法：Parallel Young GC ＋ 非并行的PS MarkSweep GC / 并行的Parallel Old GC（敲黑板！敲黑板！敲黑板！这俩实际上也是全局范围的Full GC），选PS MarkSweep GC 还是 Parallel Old GC 由参数UseParallelOldGC来控制

3.CMS算法：ParNew（Young）GC + CMS（Old）GC ＋ Full GC for CMS算法

4.G1 GC：Young GC + mixed GC（新生代，再加上部分老生代）＋ Full GC for G1 GC算法

## GC触发条件

![GC](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/GC.png)

1.Young GC：Eden区满了就触发

2.full GC：
   - 触发young gc前如果发现老年代区的剩余空间比之前的young gc的平均晋升大小要小，则直接触发full gc
   - system.gc()
   - 如果有永久代的话，永久代空间没了也触发
   - 在parallel scavenge中触发full是要先触发一次young gc而不是在触发young gc之前

## 老年代晋升条件

jvm给每个对象定义了一个年龄，Eden中的对象每熬过一次young gc年龄就+1,默认到15岁就晋升，可以通过参数设置

## 空间担保

1.空间担保由老年代进行

2.通过参数设置是否可以担保

3.本质上就是查看老年代剩余空间是否大于新生代每次平均晋升的大小

4.担保有可能失败(比如这次新生代挂的比往常多很多)，失败的话就直接触发full gc了


      
