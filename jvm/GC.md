# 垃圾回收算法

## 引用计数法

1.每个对象维护一个引用计数器

2.被引用一次计数器+1,引用失效计数器-1

3.计数器归零后对象失效

优点：高效

缺点：需要大量额外空间，无法解决两个对象相互引用的问题(a引用b，b再引用a，这样ab的引用计数器永远至少是大于0的，永远不会被回收)

## 可达性分析算法

1.假设有一个没有失效的对象，叫它GC Roots，从该点进行图遍历，被遍历到的对象就是被引用的对象，那么他们肯定也没有失效

2.没有被遍历到的对象会被标记一次或者直接失效

3.GC Roots的选取：

   - 1.虚拟机栈或本地方法栈中被引用的对象(肯定还活着)
   - 2.方法区中的静态属性和常量属性引用的对象(永生)
   - 3.虚拟机内部的引用，比如基本数据类型对应的class，常驻的一场对象啥的(永生)
   - 4.synchronized所持有的对象(阻塞)
   - 5.本地代码缓存啥的
   - 总结的话就是:永生的，肯定还活着的，阻塞的
   - 另外一些临时性对象也可以加入，还有不同内存区域内的对象也可以，上面五个是肯定可以，而不是只能是五个
   
4.四种引用：

  - 1.强引用：被引用的对象绝不会被回收
  - 2.软引用：在内存溢出前不会被回收。如果内存溢出则回收，如果回收后内存还溢出就抛异常吧
  - 3.弱引用：垃圾收集时直接被回收
  - 4.幻影引用：不光会被直接回收，而且还不能通过引用取得对象实例，这种引用的存在就是在被回收的时候发个通知
  
5.死亡过程

前面说过没有被遍历到的对象可能不会直接死亡而被标记

  - 1.被标记后再进行二次筛选，标准是是否执行了finalize()方法
  - 2.如果执行了finalize()方法则系统会像赛跑一样开始追这个对象，这个对象如果在内存回收前执行完finalize()方法则会逃生成功，如果执行的太慢or执行的优先度太低就死掉了
  - 3.finalize()方法只能执行一次，执行第二次就不管用了，对象会直接死掉
  - 4.finalize()这个方法已经不建议使用了，可以使用try+finally代替
  
6.方法区的回收

  - 1.方法区主要回收的就是废弃的常量和不再使用的类型
  - 2.判断类型是否被废弃的标准：1.该类的所有实例都挂了 2.该类的类加载器也挂了 3.该类的类型对象没有再被引用了 4.无法从任何地方反射获取该类的方法
  - 3.满足上述条件的类型可以被回收，但是不是必须回收
  
## 垃圾收集算法大类

jvm中的垃圾收集算法基本都基于分代收集，分代收集用白话说就是将内存中的对象根据其存在的时间分为青年和老头

专业的说法是：新生代，老年代，新生代时间长了变成老年代，老年代时间长了就被标记然后挂掉

其中会出现跨代引用，就是老年代引用新生代or反过来，这样的引用不好处理，但是出现概率很低，为了这部分每次kill对象的时候扫描一下全部老年代不太值，一般是在新生代上家里一块全局数据结构(记忆集

用记忆集记录那有跨代引用的内存区域，扫描的时候只扫这部分就行

分代收集中最基本的三大类算法就是标记清除和标记复制和标记整理

   - 1.标记清除：先标记，标记后统一清除 缺点：执行效率不稳定(回收对象少和多的效率区别巨大)，内存空间容易碎片化
   - 2.标记复制：将内存分成两半(比例不一定是1比1)，一半用完了就开始回收，将没挂的放到另一半上 缺点：内存只能用一半了 优点：内存空间连续了 改进：eden+两个survivor就是这么来的(appel算法)
   - 3.标记整理：每次kill完之后让所有存活对象都移动到内存空间的一端 缺点：移动的时候会停掉其他用户线程(所谓的STW Stop the World)
   
   
## 算法细节

1.根节点枚举：需要STW，但是根节点枚举耗时比较长，所以停的时间长，一般使用OopMap记录根节点记录对象内什么偏移量上是什么类型，达到快速查找根节点的目的(因为有些类型根本做不了根节点嘛)

2.安全点：给每一条指令都生成OopMap信息消耗太大，使用安全点在特定指令处生成OopMap信息，一般选择的都是能让程序长时间执行的地方，比如方法调用，循环啥的
   - 1.被动中断：安全点是固定的，每次回收的时候停掉所有在安全点的用户线程，让不在安全点的线程跑到安全点再停掉
   - 2.主动中断：安全点固定，每次回收的时候设置一个标志，不中断任何线程，线程不断轮询标志，如果标志为true，则线程找到离自己最近的安全点再断掉
   
3.安全区域：如果用户线程sleep之类的，则没办法自己跑到安全点or轮询，这个时候就用到了安全区，安全区代码要求代码内的引用关系不发生变化，线程执行到安全区代码的时候先标识一下，虚拟机回收垃圾的时候会直接略过安全去代码，出安全区的时候要看根节点枚举是否完成，完成了就直接出，没完成则需要阻塞等待完成才能出

4.记忆表和卡表：

   - 1.记忆表：记录从非回收区指向回收区的指针的集合，用于高效解决跨代引用问题
   - 2.卡表：记忆表的卡精度实现，最小单位是一块内存区域
   - 3.一般卡页内有跨代指针，则对应的卡表就变脏(标志位置为1)
   
5.写屏障：

   - 1.简单来说，这东西就是在对引用进行写操作之前or之后挂上一小段逻辑代码
   - 2.写之前叫写前屏障，写之后叫写后屏障，G1收集器之前只用到过写后屏障
   - 3.写后屏障主要用于更新卡表，让卡表变脏用的，卡表变脏的时间点就是引用被进行写操作的那一刻
   - 4.写屏障的开销比扫描整个老年代小多了

6.可达性分析和三色标记

   - 1.为了让STW尽可能短，可以让用户线程和回收器并发执行
   - 2.问题就是这样执行会使得回收的同时产生新的垃圾or被回收的对象可能同时被用户线程再次引用
   - 3.三色标记用于表示这个问题
      - 白色：未被访问过的对象，如果可达性分析结束还是白色，则该对象不可达(挂掉)
      - 黑色：被访问过并且存活
      - 灰色：被访问过，但是其指向的引用至少还有一个没被扫描过，是黑色和白色之间的交汇
   - 4.问题2出现的条件比如满足:线程插入了一条黑色到白色的新引用，然后删除了全部灰色到白色的引用。所以只要打破两条中的一条就可以解决问提2(让用户线程和回收器并发执行)
   - 5.增量更新：第一次并发回收的同时记录黑色->白色的引用关系，结束后再次扫描被记录的黑色对象
   - 6.原始快照：第一次并发回收的同时记录灰色->白色的引用关系的删除，结束后再次扫描被记录的灰色对象
   - 7.增量更新和原始快照用于打破4中的两个条件
