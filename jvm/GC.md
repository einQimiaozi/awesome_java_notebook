# 垃圾回收算法

## 引用计数法

1.每个对象维护一个引用计数器

2.被引用一次计数器+1,引用失效计数器-1

3.计数器归零后对象失效

优点：高效

缺点：需要大量额外空间，无法解决两个对象相互引用的问题(a引用b，b再引用a，这样ab的引用计数器永远至少是大于0的，永远不会被回收)

## 可达性分析算法

1.假设有一个没有失效的对象，叫它GC Roots，从该点进行图遍历，被遍历到的对象就是被引用的对象，那么他们肯定也没有失效

2.没有被遍历到的对象会被标记一次或者直接失效

3.GC Roots的选取：

   - 1.虚拟机栈或本地方法栈中被引用的对象(肯定还活着)
   - 2.方法区中的静态属性和常量属性引用的对象(永生)
   - 3.虚拟机内部的引用，比如基本数据类型对应的class，常驻的一场对象啥的(永生)
   - 4.synchronized所持有的对象(阻塞)
   - 5.本地代码缓存啥的
   - 总结的话就是:永生的，肯定还活着的，阻塞的
   - 另外一些临时性对象也可以加入，还有不同内存区域内的对象也可以，上面五个是肯定可以，而不是只能是五个
   
4.四种引用：

  - 1.强引用：被引用的对象绝不会被回收
  - 2.软引用：在内存溢出前不会被回收。如果内存溢出则回收，如果回收后内存还溢出就抛异常吧
  - 3.弱引用：垃圾收集时直接被回收
  - 4.幻影引用：不光会被直接回收，而且还不能通过引用取得对象实例，这种引用的存在就是在被回收的时候发个通知
  
5.死亡过程

前面说过没有被遍历到的对象可能不会直接死亡而被标记

  - 1.被标记后再进行二次筛选，标准是是否执行了finalize()方法
  - 2.如果执行了finalize()方法则系统会像赛跑一样开始追这个对象，这个对象如果在内存回收前执行完finalize()方法则会逃生成功，如果执行的太慢or执行的优先度太低就死掉了
  - 3.finalize()方法只能执行一次，执行第二次就不管用了，对象会直接死掉
  - 4.finalize()这个方法已经不建议使用了，可以使用try+finally代替
  
6.方法区的回收

  - 1.方法区主要回收的就是废弃的常量和不再使用的类型
  - 2.判断类型是否被废弃的标准：1.该类的所有实例都挂了 2.该类的类加载器也挂了 3.该类的类型对象没有再被引用了 4.无法从任何地方反射获取该类的方法
  - 3.满足上述条件的类型可以被回收，但是不是必须回收
  

