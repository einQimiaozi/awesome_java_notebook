# 运行时数据区域

![all](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/665375-20160126212928129-1855187537.png)

## 程序计数器

1.用作表示当前线程所执行的字节码的行号指示器

2.程序控制流的指示器，控制循环，分支，异常处理，线程恢复等

3.每个线程的计数器独立

4。如果当前线程执行的是本地方法，则计数器直接为空

5.此区域没有OutOfMemoryError错误

## 虚拟机栈

1.线程私有，为java方法(字节码)服务

2.用于存放栈帧

3.关于栈帧
  - 栈帧由局部变量表，操作数栈，动态链接，方法出口等信息组成
  - 局部变量表包含了编译期可知的各种java虚拟机基本数据类型(int,boolean这些东西，注意不包含String)和对象引用类型和热土让你Address类型(指向字节码指令的指针)
  - 局部变量表中的存储空间单位为slot，运行期间空间大小不会改变，但是slot本身的大小不一定(例如long为64bit，如果slot=32bit则long占两个slot，slot=64bit则long只占一个slot)

4.如果线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError，如果栈容量允许扩展并且内存不足会抛出OutOfMemoryError错误

5.本地方法栈和虚拟机栈不是一个东西，但是性质是一样的，只不过为本地方法服务

## java堆

1.只能存放对象实例和数组

2.被垃圾收集器管理，也叫GC堆

3.线程共享，但是可以划分出多个线程私有的分配缓冲区(TLAB)

4.逻辑空间连续，物理空间可以不连续，但是大多数虚拟机实现的时候要求物理空间也连续

5.通过Xmx和Xms设置大小，如果内存不足又无法扩展大小，抛出OutOfMemoryError

## 方法区

1.本质上也是堆，但是和java堆是两码事，线程共享，存储被虚拟机加载的类型信息，常量，静态变量，编译后的代码

2.方法区存放的数据一般是永久的，所以很早以前方法区和永久代相同，这样做使得方法区无法扩展，容易发生内存溢出，jdk8之后永久代被抛弃，，所以现在永久代和方法区不是一回事

3.物理内存可以不连续，还可以选择不实现垃圾收集，因为方法区存放的数据生命周期大多是永久的

4.会报OutOfMemoryError

5.运行时常量池：方法区的一部分，存放编译期(注意是编译期)中产生的各种字面量和符号引用，因为java不要求常量在编译期才能产生，所以和class文件常量池是不同的

6.直接内存：方法区的一部分，简单解释就是由于NIO的存在，使得本地方法可以直接在本地内存中存放，使用直接内存可以对这块本地内存进行引用，避免使用本地方法时本地堆和java堆之间来回复制数据

#对象创建
