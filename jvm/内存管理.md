# 运行时数据区域

![all](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/665375-20160126212928129-1855187537.png)

## 程序计数器

1.用作表示当前线程所执行的字节码的行号指示器

2.程序控制流的指示器，控制循环，分支，异常处理，线程恢复等

3.每个线程的计数器独立

4。如果当前线程执行的是本地方法，则计数器直接为空

5.此区域没有OutOfMemoryError错误

## 虚拟机栈

1.线程私有，为java方法(字节码)服务

2.用于存放栈帧

3.关于栈帧
  - 栈帧由局部变量表，操作数栈，动态链接，方法出口等信息组成
  - 局部变量表包含了编译期可知的各种java虚拟机基本数据类型(int,boolean这些东西，注意不包含String)和对象引用类型和热土让你Address类型(指向字节码指令的指针)
  - 局部变量表中的存储空间单位为slot，运行期间空间大小不会改变，但是slot本身的大小不一定(例如long为64bit，如果slot=32bit则long占两个slot，slot=64bit则long只占一个slot)

4.如果线程请求的栈深度大于虚拟机允许的深度，抛出StackOverflowError，如果栈容量允许扩展并且内存不足会抛出OutOfMemoryError错误

5.本地方法栈和虚拟机栈不是一个东西，但是性质是一样的，只不过为本地方法服务

## java堆

1.只能存放对象实例和数组

2.被垃圾收集器管理，也叫GC堆

3.线程共享，但是可以划分出多个线程私有的分配缓冲区(TLAB)

4.逻辑空间连续，物理空间可以不连续，但是大多数虚拟机实现的时候要求物理空间也连续

5.通过Xmx和Xms设置大小，如果内存不足又无法扩展大小，抛出OutOfMemoryError

## 方法区

1.本质上也是堆，但是和java堆是两码事，线程共享，存储被虚拟机加载的类型信息，常量，静态变量，编译后的代码

2.方法区存放的数据一般是永久的，所以很早以前方法区和永久代相同，这样做使得方法区无法扩展，容易发生内存溢出，jdk8之后永久代被抛弃，，所以现在永久代和方法区不是一回事

3.物理内存可以不连续，还可以选择不实现垃圾收集，因为方法区存放的数据生命周期大多是永久的

4.会报OutOfMemoryError

5.运行时常量池：方法区的一部分，存放编译期(注意是编译期)中产生的各种字面量和符号引用，因为java不要求常量在编译期才能产生，所以和class文件常量池是不同的

6.直接内存：方法区的一部分，简单解释就是由于NIO的存在，使得本地方法可以直接在本地内存中存放，使用直接内存可以对这块本地内存进行引用，避免使用本地方法时本地堆和java堆之间来回复制数据

# 对象

## 对象创建

1.new的时候jvm会先检查这个指令参数是否能在常量池里找到相同的类的引用

2.如果有的话检查一下是否被加载，解析和初始化

3.如果没有初始化，那么先执行相应类的加载

4.分配内存(从堆里划内存块)，分配内存有两种方式
   - 1.指针碰撞：物理内存连续的话，在使用过的没用过的内存中间放个指针就可以了
   - 2.空闲列表：如果物理内存不连续，就使用一个空闲列表记录内存空闲单位然后分配
   - 3.使用标记移动算法的回收器时用指针碰撞，使用标记清理算法的回收器时用空闲列表
   - 4.指针碰撞在高并发下线程不安全，可以使用CAS或TLAB缓冲区解决线程安全问题
   
## 对象布局

1.对象头(markword)：保存了对象自身数据(hashcode，锁标志位啥的)和指向对象类型本身的指针，jvm通过这个指针来判断对象是什么类型的，如果是数组的话还会记录一发数组长度

2.实例数据：保存了字段真正的内容

3.对齐填充：人如其名，就是对齐用的无用数据，不用管它

## 对象访问定位

1.java通过栈上的引用数据来操作堆上的数据

2.一般这个所谓的引用的底层实现有两种，句柄or指针

3.句柄：java堆中一部分内存作为句柄池，一个句柄包含对象实例指针和对象类型指针，通过两个指针在实例池里找实例，在方法区里找类型

4.指针：指针的话直接在java堆里存放数据，一个指针包含对象实例的数据和类型指针，相比句柄由于实例已经存在堆里了所以少一次指针定位，访问开销小

## 内存屏障

用于同步两个线程，控制特定条件下的重排序和内存可见性问题，Java编译器也会根据内存屏障的规则禁止处理器重排序，java中有四种内存屏障

1.LoadLoad屏障：举例语句是Load1; LoadLoad; Load2(这句里面的LoadLoad里面的第一个Load对应Load1加载代码，然后LoadLoad里面的第二个Load对应Load2加载代码)，此时的意思就是在Load2加载代码在要读取的数据之前，保证Load1加载代码要从主内存里面读取的数据读取完毕。

2.StoreStore屏障：举例语句是 Store1; StoreStore; Store2(这句里面的StoreStore里面的第一个Store对应Store1存储代码，然后StoreStore里面的第二个Store对应Store2存储代码)。此时的意思就是在Store2存储代码进行写入操作执行前，保证Store1的写入操作已经把数据写入到主内存里面，确认Store1的写入操作对其它处理器可见。

3.LoadStore屏障：举例语句是 Load1; LoadStore; Store2(这句里面的LoadStore里面的Load对应Load1加载代码，然后LoadStore里面的Store对应Store2存储代码)，此时的意思就是在Store2存储代码进行写入操作执行前，保证Load1加载代码要从主内存里面读取的数据读取完毕。

4.StoreLoad屏障：举例语句是Store1; StoreLoad; Load2(这句里面的StoreLoad里面的Store对应Store1存储代码，然后StoreLoad里面的Load对应Load2加载代码)，在Load2加载代码在从主内存里面读取的数据之前，保证Store1的写入操作已经把数据写入到主内存里面，确认Store1的写入操作对其它处理器可见。




