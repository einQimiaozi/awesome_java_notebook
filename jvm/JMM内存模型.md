## JMM的由来

JMM主要用于处理普通模型的执行顺序问题，即指令重排序问题

由于普通内存模型是处理器->高速缓存->缓存一致性协议->主内存，所以几个不同的高速缓存虽然通过缓存一致性协议可以保证速度相同，但是就没办法保证执行顺序相同了

![jmm](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/jmm.png)

jmm定义了程序中各种变量的访问规则，但不包括线程私有的局部变量和方法参数。

java中所有变量都存放在jmm的主内存中，每条线程还保存自己的工作内存，其中存放了被该线程使用的变量在主内存中的副本

线程之间变量的传递均需要在主内存中完成

## 内存模型的操作

1.lock：标识线程独占变量，用于主内存

2.unlock：释放lock

3.read：将主内存中变量的值传输到线程工作内存中，用于主内存

4.load：把read得到的值放入工作线程的副本中，用于工作内存

5.use：将工作内存中变量的值传递给执行引擎，遇到使用变量的字节码时触发，用于工作内存

6.assign：接收执行引擎传来的值，赋给工作内存的变量副本，遇到使用变量的字节码时触发，用于工作内存

7.store：把工作内存中变量副本的值传给主内存，用于工作内存

8.write：把工作内存传来的值赋给主内存的变量，用于主内存

使用规则：

  - read-load和sore-write操作必须成对出现
  - 工作变量的值被修改后必须及时赋给主内存，也就是说assign操作工作内存后不能不管主内存
  - assign操作是唯一一种工作内存能够赋值给主内存的情况
  - 工作内存不能自己产生变量，不是assign，就是load
  - lock是可重入锁
  - 无lock，不能unlock
  - unlock前，必须把变量同步回主内存

## 指令重排序：java虚拟机的即使编译器支持指令重排序

1.编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的顺序

2.指令级并行重排序：如果不存在数据之间的依赖，处理器可以改变语句对应机器指令的执行顺序

3.内存系统的重排序：处理器使用缓存和读写缓冲区，使加载和存储操作看上去可能是在乱序执行，但是其实顺序是没问题的
