## JMM的由来

JMM主要用于处理普通模型的执行顺序问题，即指令重排序问题

由于普通内存模型是处理器->高速缓存->缓存一致性协议->主内存，所以几个不同的高速缓存虽然通过缓存一致性协议可以保证速度相同，但是就没办法保证执行顺序相同了

![jmm](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/jvm/Resources/jmm.png)

jmm定义了程序中各种变量的访问规则，但不包括线程私有的局部变量和方法参数。

java中所有变量都存放在jmm的主内存中，每条线程还保存自己的工作内存，其中存放了被该线程使用的变量在主内存中的副本

线程之间变量的传递均需要在主内存中完成

## 内存模型的操作

1.lock：标识线程独占变量，用于主内存

2.unlock：释放lock

3.read：将主内存中变量的值传输到线程工作内存中，用于主内存

4.load：把read得到的值放入工作线程的副本中，用于工作内存

5.use：将工作内存中变量的值传递给执行引擎，遇到使用变量的字节码时触发，用于工作内存

6.assign：接收执行引擎传来的值，赋给工作内存的变量副本，遇到使用变量的字节码时触发，用于工作内存

7.store：把工作内存中变量副本的值传给主内存，用于工作内存

8.write：把工作内存传来的值赋给主内存的变量，用于主内存

使用规则：

  - read-load和sore-write操作必须成对出现
  - 工作变量的值被修改后必须及时赋给主内存，也就是说assign操作工作内存后不能不管主内存
  - assign操作是唯一一种工作内存能够赋值给主内存的情况
  - 工作内存不能自己产生变量，不是assign，就是load
  - lock是可重入锁
  - 无lock，不能unlock
  - unlock前，必须把变量同步回主内存

## 指令重排序：java虚拟机的即使编译器支持指令重排序

1.编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的顺序

2.指令级并行重排序：如果不存在数据之间的依赖，处理器可以改变语句对应机器指令的执行顺序

3.内存系统的重排序：处理器使用缓存和读写缓冲区，使加载和存储操作看上去可能是在乱序执行，但是其实顺序是没问题的

## happen-before原则

用于两个线程的同步，向程序员提供跨线程的内存可见性保证

原则：
  - 1.如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
  - 2.两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么jvm允许这种重排序
  
四种规则：
  - 1.程序顺序规则：线程中每个操作执行结构都对后续操作可见并且顺序在后续操作之前
  - 2.监视器锁规则：对于一个锁的解锁操作，其结果对后续的加锁操作可见并在其之前
  - 3.volatile域规则：对于一个volatile域的写操作，其结果和执行顺序在后续任意线程(注意是任意线程)的读操作之前
  - 4.传递性规则：如果线程a happens-before 线程b，且线程b happens-before 线程c，那么线程a happens-before 线程c
