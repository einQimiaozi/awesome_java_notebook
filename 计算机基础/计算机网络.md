## 单工，半双工，全双工

1.单工：只允许同一时刻a发给b一条消息，同时a只能发，b只能接

2.半双工：a和b都可以发送接收，但是同一时刻只能收发一次

3.全双工：a和b都可以发送接收，并且同一时刻可以收发多条

# OSI七层模型

![arch](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/arch.png)

1.物理层：
  - 使用物理硬件(网线之类的)传输电信号，010101010......，也就是所谓的比特流
  
2.数据链路层：
  - 比特流这东西都一堆0101啥的，接收之后不好解读，数据链路层就把这些比特流按照8bit一组(其实就是1字节)分组
  - 多组比特流组一个帧(数据包)
  - 数据包的组成如下：
    - head(18byte，666组成):发送者（源地址，6个字节）接收者（目标地址，6个字节）数据类型（6个字节）
    - data(46-1500byte)：数据本身
  - 源地址和目标地址都是mac地址，mac地址其实就是网卡的物理地址
  - 数据链路层只能在局域网内通信，依靠广播机制(大喊一声我是xxx我要找xxx要xxx，然后在座的各位对号入座)
  - 同时这一层要对比特流封装的帧做数据差错检测和尝试修复
  - 所以这一层的功能是：透明传输，封装成帧，差错检测
  
3.网络层：
  - 数据链路层无法解决广域网传输的问题就要依靠网络层解决
  - 解决的方案就是ip协议
  - 使用网关作为不同局域网之间的代理人，通过网关的ip地址我们可以直接找到目标所在的网关所负责的局域网，然后广播，根据mac地址找到目标，这就是ip协议干的事，但想要知道目标的mac地址，需要使用arp协议
  - arp的原理：使用12个f作为目标地址的mac，然后大喊一声我要获取ip为xxx的xxx的mac地址，然后大家会开始对号入座，如果ip和自己相同就直接返回自己的mac地址，在广域网内目标的ip地址就变为网关的ip地址了
  - 总结一下：使用ip协议找到网关对应的局域网，使用mac地址找到该局域网内我们要找的主机
  
4.传输层：
  - 建立主机和主机之间两个应用的端口到端口之间的通信，tcp和upd协议就是在这一层
  - 补充：端口范围0-65535，0-1023为系统占用端口
  
5.会话层：
  - 上面的传输层只负责根据端口建立应用之间的联系，而会话层则负责管理这些连接的建立，通信和终止
  
6.表示层：
  - 这一层负责将应用层送下来or会话层送上去的数据进行格式的统一处理（编码解码之类的），就是说让两个不同的主机的应用之间可以无视数据包格式不一致的问题
  
7.应用层：
  - 这一层用于规定用户自己的应用的数据格式（就是所谓协议），这样送给表示层方便它处理，常见的协议有http https ftp pop3等
  
# 协议

协议的本质就是对电脑和电脑之间如何连接和组网制定的规定

1.以太网协议：
  - 就是我们上面提到过的局域网内发送的数据包的规定

2.ip协议
  - 规定网络ip地址的协议
  - 32个二进制组成，常见的有ipv4和ipv6两种
  - 一般表示为四段十进制，从0.0.0.0到255.255.255.255
  - 处于同一局域网内的主机的ip地址必有一部分相同，子网掩码就是用来表示哪部分适用于判断是否在同一局域网内的部分的
  - ip协议发送的数据包叫ip数据包，结构比mac地址传输的数据包多了一个ip地址+长度+版本信息部分的head，长度为20到60字节，最大长度为65535字节，超过1500字节的部分分割发送

3.Arp协议
  - 之前说过了

4.udp协议
  - 数据包的head里加入了端口信息，然后整个数据包被放入到ip数据包里
  - 所以udp协议的数据包有三个head，ip数据包的两个和自己端口信息的一个，整体结构就是 以太网head+iphead+udphead+数据本身
  - 发出之后就不管了，不要求对方返回
  - 传输的是数据报文段

5.tcp协议：
  - 和udp的主要区别在于要求对方接收到每个数据包都返回确认，如果没收到确认就重传一次，并且tcp数据包没有数据长度限制，所以传输的其实是字节流
  
## tcp的三次握手

![tcp](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/tcp.jpg)

上面是tcp数据报的大概结构，有几个需要关注的地方
  - 序列号：4字节，用来表示字节的编号，一般一个报文段的序列号就是这个报文段中地一个字节的序列号
  - 确认号：4字节，希望收到的下一个数据段的序列号，一般就是当前报文段中最后一个字节的序列号+1
  - ACK：1bit，ack=1，确认号有效，ack=0.确认号无效
  - syn：1bit，连接建立时用于同步序列号，syn=1 ack=0表示这是一个连接请求，syn=1 ack=1表示同意连接，当握手完成后，syn置为0
  - fin：1bit，用于释放连接，fin=1,保温段的发送方数据发送完毕，要求释放连接
  
## 建立连接的三次握手过程

1.主机a向主机b发送数据包，syn=1,ack=0,并包含了数据段序列号t

2.主机b接收数据包后向主机a返回数据包，syn=1,ack=1,并包含了数据段序列号y，同时设置确认号为t+1

3.主机a收到主机b的确认报文后，发送一个序列号为t+1,确认号为y+1的确认报文

正常情况下使用两次握手就可以完成传输过程，第三次握手是为了防止数据重传的

比如主机a发了数据包1给主机b，因为延迟送达所以主机a没收到确认回复，主机a以为丢包了，就又发了一次数据包2，但是此时主机b已经收到数据包1了，所以连接已经建立了，主机b返回给主机a确认数据包1,但是主机a以为数据包1丢包了，所以根本不会鸟这个确认请求，但是主机b不知道，所以它就会一直等着主机a再次给它发包，造成资源的极大浪费，有了第三次握手，相当与主机a会再次确认一下，这样就防止了重传的情况

## 释放链接的四次握手

1.关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u

2.服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。

3.关闭服务器到客户端的连接：也是发送一个FIN给客户端。

4.客户端收到FIN后等带2msl，并同时(注意，这个同时不需要等2msl)发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。

两个问题
  - 1.为什么要等待2msl：因为客户端发给服务器的最后一个包有可能丢包，如果丢包了，则需要服务器超时重传，即从第三次握手重新执行，但是如果客户端不等待直接关了连接，那么服务器就不能重传给客户端任何东西了，这样服务器这一端由于收不到closed包，就会一直等待而不关闭连接，造成阻塞。
  - 2.为什么要四次握手：因为tcp是全双工模式，所以服务端和客户端要想关闭只能自己关自己，那么就需要各自通知一下对方自己要关了(这个叫半关闭)，所以是四次握手
  
## tcp传输可靠的原因：

1.包排序(序列号)

2.超时重传

3.流量控制(TCP窗口中会指明双方能够发送接收的最大数据量)

4.拥塞控制(慢启动，快重传，避免拥塞，快恢复)

## tcp的粘包问题

问题描述：

  - 情况1：tcp在发送数据包过程中会启动nagle算法，自动将较小的包合并发送，接收端此时无法分辨哪些包是需要发送端分开发送的，就产生了粘包
  - 情况2：接收端收到数据后放在缓冲区里没有及时取走造成下一次取出数据时一次取出了多个包
  
解决方法：

  - 1.在包尾添加分割符
  - 2.消息定长，每个报文大小固定，如果不够则补空格
  - 3.在消息头中包含消息总长度
  
## 半包问题

问题描述：
  - 情况1：接收端分两次读取到了数据包a和b，其中a不完整，b包含了a的剩余内容和自己的全部内容(或者b的一部分内容)
  - 产生原因：丢包，分片传输或者一个包被重传了两次
  
解决方法：同tcp粘包

## tcp为何采用随机序列号

1.防止被黑(黑客猜测序列号后伪装tcp报文)

2.假设客户端发出的数据包a在网络中滞留了，客户端进行了重传数据包b，此时服务器收到数据包b并建立了新连接，如果a和b使用的是相同的序列号那么此时服务器收到数据包a后可能还会接收，导致服务器接收了已经无意义的数据包，可能产生错误



