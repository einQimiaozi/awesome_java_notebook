## 单工，半双工，全双工

1.单工：只允许同一时刻a发给b一条消息，同时a只能发，b只能接

2.半双工：a和b都可以发送接收，但是同一时刻只能收发一次

3.全双工：a和b都可以发送接收，并且同一时刻可以收发多条

## 长连接和短连接

1.长连接：连接->传输数据->保持连接 -> 传输数据-> ...........->直到一方关闭连接，多是客户端关闭连接,http1.1就是长连接，优点是避免了资源消耗时间消耗，缺点是连接不断，对服务器有负担

2.短连接：连接->传输数据->关闭连接，http1.0就是短连接，优点是传输后关闭，可以减少连接的管理，缺点是增加了时间消耗和资源消耗(每次都要三次握手四次释放)

# OSI七层模型

![arch](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/arch.png)

1.物理层：
  - 使用物理硬件(网线之类的)传输电信号，010101010......，也就是所谓的比特流
  
2.数据链路层：
  - 比特流这东西都一堆0101啥的，接收之后不好解读，数据链路层就把这些比特流按照8bit一组(其实就是1字节)分组
  - 多组比特流组一个帧(数据包)
  - 数据包的组成如下：
    - head(18byte，666组成):发送者（源地址，6个字节）接收者（目标地址，6个字节）数据类型（6个字节）
    - data(46-1500byte)：数据本身
  - 源地址和目标地址都是mac地址，mac地址其实就是网卡的物理地址
  - 数据链路层只能在局域网内通信，依靠广播机制(大喊一声我是xxx我要找xxx要xxx，然后在座的各位对号入座)
  - 同时这一层要对比特流封装的帧做数据差错检测和尝试修复
  - 所以这一层的功能是：透明传输，封装成帧，差错检测
  
3.网络层：
  - 数据链路层无法解决广域网传输的问题就要依靠网络层解决
  - 解决的方案就是ip协议
  - 使用网关作为不同局域网之间的代理人，通过网关的ip地址我们可以直接找到目标所在的网关所负责的局域网，然后广播，根据mac地址找到目标，这就是ip协议干的事，但想要知道目标的mac地址，需要使用arp协议
  - arp的原理：使用12个f作为目标地址的mac，然后大喊一声我要获取ip为xxx的xxx的mac地址，然后大家会开始对号入座，如果ip和自己相同就直接返回自己的mac地址，在广域网内目标的ip地址就变为网关的ip地址了
  - 总结一下：使用ip协议找到网关对应的局域网，使用mac地址找到该局域网内我们要找的主机
  
4.传输层：
  - 建立主机和主机之间两个应用的端口到端口之间的通信，tcp和upd协议就是在这一层
  - 补充：端口范围0-65535，0-1023为系统占用端口
  
5.会话层：
  - 上面的传输层只负责根据端口建立应用之间的联系，而会话层则负责管理这些连接的建立，通信和终止
  
6.表示层：
  - 这一层负责将应用层送下来or会话层送上去的数据进行格式的统一处理（编码解码之类的），就是说让两个不同的主机的应用之间可以无视数据包格式不一致的问题
  
7.应用层：
  - 这一层用于规定用户自己的应用的数据格式（就是所谓协议），这样送给表示层方便它处理，常见的协议有http https ftp pop3等
  
# 协议

协议的本质就是对电脑和电脑之间如何连接和组网制定的规定

1.以太网协议：
  - 就是我们上面提到过的局域网内发送的数据包的规定

2.ip协议
  - 规定网络ip地址的协议
  - 32个二进制组成，常见的有ipv4和ipv6两种
  - 一般表示为四段十进制，从0.0.0.0到255.255.255.255
  - 处于同一局域网内的主机的ip地址必有一部分相同，子网掩码就是用来表示哪部分适用于判断是否在同一局域网内的部分的
  - ip协议发送的数据包叫ip数据包，结构比mac地址传输的数据包多了一个ip地址+长度+版本信息部分的head，长度为20到60字节，最大长度为65535字节，超过1500字节的部分分割发送

3.Arp协议
  - 之前说过了

4.udp协议
  - 数据包的head里加入了端口信息，然后整个数据包被放入到ip数据包里
  - 所以udp协议的数据包有三个head，ip数据包的两个和自己端口信息的一个，整体结构就是 以太网head+iphead+udphead+数据本身
  - 发出之后就不管了，不要求对方返回
  - 传输的是数据报文段

5.tcp协议：
  - 和udp的主要区别在于要求对方接收到每个数据包都返回确认，如果没收到确认就重传一次，并且tcp数据包没有数据长度限制，所以传输的其实是字节流
  
## tcp的三次握手

![tcp](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/tcp.jpg)

上面是tcp数据报的大概结构，有几个需要关注的地方
  - 序列号：4字节，用来表示字节的编号，一般一个报文段的序列号就是这个报文段中地一个字节的序列号
  - 确认号：4字节，希望收到的下一个数据段的序列号，一般就是当前报文段中最后一个字节的序列号+1
  - ACK：1bit，ack=1，确认号有效，ack=0.确认号无效
  - syn：1bit，连接建立时用于同步序列号，syn=1 ack=0表示这是一个连接请求，syn=1 ack=1表示同意连接，当握手完成后，syn置为0
  - fin：1bit，用于释放连接，fin=1,保温段的发送方数据发送完毕，要求释放连接
  
## 建立连接的三次握手过程

1.主机a向主机b发送数据包，syn=1,ack=0,并包含了数据段序列号t

2.主机b接收数据包后向主机a返回数据包，syn=1,ack=1,并包含了数据段序列号y，同时设置确认号为t+1

3.主机a收到主机b的确认报文后，发送一个序列号为t+1,确认号为y+1的确认报文

正常情况下使用两次握手就可以完成传输过程，第三次握手是为了防止数据重传的

比如主机a发了数据包1给主机b，因为延迟送达所以主机a没收到确认回复，主机a以为丢包了，就又发了一次数据包2，但是此时主机b已经收到数据包1了，所以连接已经建立了，主机b返回给主机a确认数据包1,但是主机a以为数据包1丢包了，所以根本不会鸟这个确认请求，但是主机b不知道，所以它就会一直等着主机a再次给它发包，造成资源的极大浪费，有了第三次握手，相当与主机a会再次确认一下，这样就防止了重传的情况

## 释放链接的四次握手

1.关闭客户端到服务器的连接：首先客户端A发送一个FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u

2.服务器收到这个FIN，它发回一个ACK，确认号ack为收到的序号加1。

3.关闭服务器到客户端的连接：也是发送一个FIN给客户端。

4.客户端收到FIN后等带2msl，并同时(注意，这个同时不需要等2msl)发回一个ACK报文确认，并将确认序号seq设置为收到序号加1。

两个问题
  - 1.为什么要等待2msl：因为客户端发给服务器的最后一个包有可能丢包，如果丢包了，则需要服务器超时重传，即从第三次握手重新执行，但是如果客户端不等待直接关了连接，那么服务器就不能重传给客户端任何东西了，这样服务器这一端由于收不到closed包，就会一直等待而不关闭连接，造成阻塞。
  - 2.为什么要四次握手：因为tcp是全双工模式，所以服务端和客户端要想关闭只能自己关自己，那么就需要各自通知一下对方自己要关了(这个叫半关闭)，所以是四次握手
  
## tcp传输可靠的原因：

1.包排序(序列号)

2.超时重传

3.流量控制(TCP窗口中会指明双方能够发送接收的最大数据量)

4.拥塞控制(慢启动，快重传，避免拥塞，快恢复)

## tcp的粘包问题

问题描述：

  - 情况1：tcp在发送数据包过程中会启动nagle算法，自动将较小的包合并发送，接收端此时无法分辨哪些包是需要发送端分开发送的，就产生了粘包
  - 情况2：接收端收到数据后放在缓冲区里没有及时取走造成下一次取出数据时一次取出了多个包
  
解决方法：

  - 1.在包尾添加分割符
  - 2.消息定长，每个报文大小固定，如果不够则补空格
  - 3.在消息头中包含消息总长度
  
## 半包问题

问题描述：
  - 情况1：接收端分两次读取到了数据包a和b，其中a不完整，b包含了a的剩余内容和自己的全部内容(或者b的一部分内容)
  - 产生原因：丢包，分片传输或者一个包被重传了两次
  
解决方法：同tcp粘包

## tcp为何采用随机序列号

1.防止被黑(黑客猜测序列号后伪装tcp报文)

2.假设客户端发出的数据包a在网络中滞留了，客户端进行了重传数据包b，此时服务器收到数据包b并建立了新连接，如果a和b使用的是相同的序列号那么此时服务器收到数据包a后可能还会接收，导致服务器接收了已经无意义的数据包，可能产生错误

## http

1.什么是Http协议：客户端和服务器端之间数据传输的格式规范，格式简称为“超文本传输协议”，属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议

2.特点：

  - 1.支持客户端/服务端模式
  - 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
  - 3.灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。
  - 4.无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，使用Cookie和Session记录http状态
  - 5.无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传
  
3.URI和URL

  - 1.URI：用来标示一个具体的资源(是什么)
  - 2.URL：用来定位具体的资源(在哪儿)
  
4.http报文组成：
  
  1.请求报文
    - 请求行：包括请求方法、URL、协议/版本
    - 请求头(Request Header)
    - 请求正文
  
  2.响应报文
    - 状态行
    - 响应头
    - 响应正文
    
5.GET和POST
  - get,post,put,delete对应着url定位的资源的查，改，增，删四种操作
  - get请求安全且不改变服务信息，post则会修改服务器信息
  - get可以在url里带参数，所以有时候post的操作直接使用get也可以，注意参数会暴露在外就行(post提交参数用的是post的表单)
  - 本质上get+post可以完成增删改查所有操作了

6.Cookie和Session
  - 因为http为无状态协议，所以使用二者保存状态
  - Cookie存在客户端，存的是变量，单个最大不能超过4kb，不安全
  - Session存在服务器端，存的是散列表结构下的键值对，会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
  - 创建Session时要先检查客户端的请求里是否包含了sesstion id，如果包含了就按照id取出session，否则就新建，保存session id的方法其实使用了cookie
  - 两者区别：
     - 1.存取方式不同(session用数据结构存任何类型，cookie存字符串)
     - 2.隐私策略不同
     - 3.浏览器支持不同(cookie上限4k，有些浏览器限制一个站点最多20个cookie)
     - 4.有效期不同(Session不永久)
     - 5.服务器压力不同
     - 6.跨域支持不同(Session无法跨域，a.b.com和b.b.com不通用，使用cookie存sessionid才可以跨域)
 
 7.URL重写：url重写用于解决浏览器禁用cookie的情况，原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。这样即使客户端不支持Cookie，也可以使用Session来记录用户状态。
 
 8.流水线：http请求是按顺序发出的，所以请求a没被服务器接收之前，他后面的请求b就阻塞，流水线就是在同一条长连接尚连续发出请求，而不用等待响应返回，这样可以减少延迟
 
 9.http1.1新特性
 
  - 1.默认长连接
  - 2.支持流水线
  - 3.支持同时打开多个tcp连接
  - 4.支持虚拟主机(使得一台服务器拥有多个域名并逻辑上被划分为多台服务器)
  - 5.新增100状态码
  - 6.支持分块传输编码
  - 7.新增缓存处理指令max-age
 
10.http1.x缺陷：
  - 1.客户端需要多链接下才能实现并发
  - 2.不会压缩请求和响应首部导致流量浪费
  - 3.不支持有效的资源优先级，导致底层tcp利用率低下

11.http2.0新特性
  - 1.支持多路复用(允许一个http2.0连接发起多重请求-响应消息)
  - 2.将通信基本单位缩小为帧
  - 3.首部压缩(huffman编码压缩首部，发送资源时一次性把所有相关资源全发给客户端，服务器和客户端同时维护一个首部字段表缓存之前见过的首部)
  - 4.服务端推送(服务器可以对客户端的一个请求发送多个响应)

12.http1.0/1.1/2.0区别
  - 1.http1.0：
    - 短连接导致连接不能复用
    - 线头阻塞：请求队列的第一个请求如果不能被处理，后续的请求都要等着
  - 2.http1.1
    - 支持长连接了(永久链接，使用request和response中的header中的connection控制，属性为close/keep-alive)
    - 增加了请求头和响应头来扩充功能
    - 可以不等待上一次结果返回后再次请求，但服务器处理请求必须按顺序
  -3.http2.0：上面有
  
13.https

  - HTTPS=HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密
  - SSL层主要是做加密处理，http层直接与SSL层通信，SSL层在传输层和应用层之间
  - HTTPS的传输流程
    - 首先客户端通过URL访问服务器建立SSL连接
    - 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
    - 客户端和服务器开始协商SSL连接的安全等级，也就是信息加密的等级
    - 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用服务器的公钥将会话密钥加密，并传送给服务器
    - 服务器利用网站公钥解密出会话密钥
    - 服务器利用会话密钥加密与客户端之间的通信
  - 缺点：
    - HTTPS协议多次握手，导致页面的加载时间延长近50%
    - HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗
    - 申请SSL证书需要钱，功能越强大的证书费用越高
    - SSL涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大
  - http和https的默认端口也不一样，http是80，https是443


14.HSTS

  - HTTP Strict-Transport-Security，它是一个Web安全策略机制（web security policy mechanism）
  - HSTS强制浏览器对当前访问的站点及其子域全部使用https访问以保证安全性
  




