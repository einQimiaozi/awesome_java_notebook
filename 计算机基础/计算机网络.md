# OSI七层模型

![arch](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/arch.png)

1.物理层：
  - 使用物理硬件(网线之类的)传输电信号，010101010......，也就是所谓的比特流
  
2.数据链路层：
  - 比特流这东西都一堆0101啥的，接收之后不好解读，数据链路层就把这些比特流按照8bit一组(其实就是1字节)分组
  - 多组比特流组一个帧(数据包)
  - 数据包的组成如下：
    - head(18byte，666组成):发送者（源地址，6个字节）接收者（目标地址，6个字节）数据类型（6个字节）
    - data(46-1500byte)：数据本身
  - 源地址和目标地址都是mac地址，mac地址其实就是网卡的物理地址
  - 数据链路层只能在局域网内通信，依靠广播机制(大喊一声我是xxx我要找xxx要xxx，然后在座的各位对号入座)
  - 同时这一层要对比特流封装的帧做数据差错检测和尝试修复
  - 所以这一层的功能是：透明传输，封装成帧，差错检测
  
3.网络层：
  - 数据链路层无法解决广域网传输的问题就要依靠网络层解决
  - 解决的方案就是ip协议
  - 使用网关作为不同局域网之间的代理人，通过网关的ip地址我们可以直接找到目标所在的网关所负责的局域网，然后广播，根据mac地址找到目标，这就是ip协议干的事，但想要知道目标的mac地址，需要使用arp协议
  - arp的原理：使用12个f作为目标地址的mac，然后大喊一声我要获取ip为xxx的xxx的mac地址，然后大家会开始对号入座，如果ip和自己相同就直接返回自己的mac地址，在广域网内目标的ip地址就变为网关的ip地址了
  - 总结一下：使用ip协议找到网关对应的局域网，使用mac地址找到该局域网内我们要找的主机
  
4.传输层：
  - 建立主机和主机之间两个应用的端口到端口之间的通信，tcp和upd协议就是在这一层
  - 补充：端口范围0-65535，0-1023为系统占用端口
  
5.会话层：
  - 上面的传输层只负责根据端口建立应用之间的联系，而会话层则负责管理这些连接的建立，通信和终止
  
6.表示层：
  - 这一层负责将应用层送下来or会话层送上去的数据进行格式的统一处理（编码解码之类的），就是说让两个不同的主机的应用之间可以无视数据包格式不一致的问题
  
7.应用层：
  - 这一层用于规定用户自己的应用的数据格式（就是所谓协议），这样送给表示层方便它处理，常见的协议有http https ftp pop3等
  
# 协议

协议的本质就是对电脑和电脑之间如何连接和组网制定的规定

1.以太网协议：
  - 就是我们上面提到过的局域网内发送的数据包的规定

2.ip协议
  - 规定网络ip地址的协议
  - 32个二进制组成，常见的有ipv4和ipv6两种
  - 一般表示为四段十进制，从0.0.0.0到255.255.255.255
  - 处于同一局域网内的主机的ip地址必有一部分相同，子网掩码就是用来表示哪部分适用于判断是否在同一局域网内的部分的
  - ip协议发送的数据包叫ip数据包，结构比mac地址传输的数据包多了一个ip地址+长度+版本信息部分的head，长度为20到60字节，最大长度为65535字节，超过1500字节的部分分割发送

3.Arp协议
  - 之前说过了

4.udp协议
  - 数据包的head里加入了端口信息，然后整个数据包被放入到ip数据包里
  - 所以udp协议的数据包有三个head，ip数据包的两个和自己端口信息的一个，整体结构就是 以太网head+iphead+udphead+数据本身
  - 发出之后就不管了，不要求对方返回
  - 传输的是数据报文段

5.tcp协议：
  - 和udp的主要区别在于要求对方接收到每个数据包都返回确认，如果没收到确认就重传一次，并且tcp数据包没有数据长度限制，所以传输的其实是字节流
