## 1. 并发

- 并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

- 并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。

## 2. 虚拟

- 主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

- 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

- 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。

## 操作系统的基本功能

  1. 进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

  2. 内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等。

  3. 文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等。

  4. 设备管理：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

## 宏内核和微内核

  1. 宏内核：宏内核是将操作系统功能作为一个紧密结合的整体放到内核。由于各模块共享信息，因此有很高的性能。

  2. 微内核：
  
    由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。
  
    移出的部分根据分层的原则划分成若干服务，相互独立。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。
  
    因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。
  
## 中断分类

  1. 外中断：由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。

  2. 异常：由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

  3. 陷入：在用户程序中使用系统调用。
  
## 进程和线程

  1. 进程：
  
    进程是资源分配的基本单位。

    进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。
  
  2. 线程
  
    线程是独立调度的基本单位。

    一个进程中可以有多个线程，它们共享进程资源。
  
  3.进程和线程的区别
  
  3. 区别
  - Ⅰ 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

  - Ⅱ 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

  - Ⅲ 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

  - Ⅳ 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程状态切换

  ![state](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/state.png)

   - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
   
   - 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

  - 1.1 先来先服务 first-come first-serverd（FCFS）

    非抢占式的调度算法，按照请求的顺序进行调度。

    有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

  - 1.2 短作业优先 shortest job first（SJF）

    非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

    长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

  - 1.3 最短剩余时间优先 shortest remaining time next（SRTN）

    最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

  - 2.1 时间片轮转

    将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

    时间片轮转算法的效率和时间片的大小有很大关系：

    因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
而如果时间片过长，那么实时性就不能得到保证。


  - 2.2 优先级调度

    为每个进程分配一个优先级，按优先级进行调度。

    为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

  - 2.3 多级反馈队列

    一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

    多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

    每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

    可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

3. 实时系统

  - 实时系统要求一个请求在一个确定时间内得到响应。

  - 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

## 进程同步

  - 1. 临界区

    对临界资源进行访问的那段代码称为临界区。

    为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。
    
  - 2. 同步与互斥
  
    同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
    
    互斥：多个进程在同一时刻只有一个进程能进入临界区。
    
  - 3. 信号量
  
    是个整型变量，本质其实就是个计数器，也可以限定其值为[0,1]作为锁(互斥量)，用于给缓冲区加锁
    
    可以用于解决生产者消费者模型，这里需要使用三个信号量：
      - empty 记录空缓冲区的数量
      - full 记录满缓冲区的数量
      - mutex作为互斥量
      
    注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。
    
## 进程通信

  1. 管道
  
    管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

    它具有以下限制：

    - 只支持半双工通信（单向交替传输）；
    
    - 只能在父子进程或者兄弟进程中使用。
    
  2. FIFO(命名管道)
  
    去除了管道只能在父子进程中使用的限制。
    
  3. 消息队列
  
    相比于 FIFO，消息队列具有以下优点：

    消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
    
    避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
    
    读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。
    
  6. 套接字
  
    与其它通信机制不同的是，它可用于不同机器间的进程通信。

### pipe，fifo和消息队列的区别

  - fifo和pipe在管道开启之前必须发送端和接收端的两个进程都准备就绪，消息队列则可以不需要接收端准备，发送端也可以发送
  
  - IPC的持续性不同。管道和FIFO是随进程的持续性，当管道和FIFO最后一次关闭发生时，仍在管道和FIFO中的数据会被丢弃。
  
  - 消息队列是随内核的持续性，即一个进程向消息队列写入消息后，然后终止，另外一个进程可以在以后某个时刻打开该队列读取消息。只要内核没有重新自举，消息队列没有被删除。

### 死锁产生的条件(cyc2018里写的不太对)

  - 互斥条件：临界资源是独占资源，进程应互斥且排他的使用这些资源。
  
  - 占有和等待条件：进程在请求资源得不到满足而等待时，不释放已占有资源。
  
  - 不剥夺条件：又称不可抢占，已获资源只能由进程自愿释放，不允许被其他进程剥夺。
  
  - 循环等待条件：又称环路条件，存在循环等待链，其中，每个进程都在等待链中等待下一个进程所持有的资源，造成这组进程处于永远等待状态。
  
## 死锁的处理方法

  - 鸵鸟策略：不处理死锁
  
  - 死锁检测与死锁恢复：死锁检测采用银行家算法或图遍历，死锁恢复在下面说明
  
    - 资源剥夺法：剥夺陷于死锁的进程所占用的资源，但并不撤销此进程，直至死锁解除。
    
    - 进程回退法：根据系统保存的检查点让所有的进程回退，直到足以解除死锁，这种措施要求系统建立保存检查点、回退及重启机制。
    
    - 进程撤销法
    
      - 撤销陷入死锁的所有进程，解除死锁，继续运行。
      
      - 逐个撤销陷入死锁的进程，回收其资源并重新分配，直至死锁解除。
      
  
  - 死锁预防
  
    1. 破坏互斥条件

    2. 破坏占有和等待条件：一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

    3. 破坏不可抢占条件
    
    4. 破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源。
  
  - 死锁避免：使用的也是银行家算法
  
  - 图遍历：适用与每种类型只有一个资源的情况
  
    - 根据思索产生的条件4可以推出死锁的多个进程之间必然存在一个有向有环图，所以可以使用深度优先搜索遍历进程。
    
    - 每次遍历过的进程进行标记，如果遍历到被标记过得进程则必然存在死锁。
    
  - 银行家算法：适用于多个一个类型有多个资源和死锁避免检测方法
  
    - 利用向量E记录当前系统剩余资源，分量为各个资源的剩余数量
    
    - 利用矩阵R记录当前系统中每个进程所需要的资源，其中每个向量代表每个进程，分量同向量E
    
    - 利用矩阵C记录当前系统中每个进程所占有的资源
    
    - 1. 遍历R寻找E条件所能满足的进程a，如果没有则会产生死锁
    
    - 2. 假设进程a执行，释放矩阵C中a对应的资源，加入到矩阵R中，重复2
    
    - 3. 若进程全部执行完毕，则不会产生死锁
    
## 分页系统地址映射

  - 内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。
  
  - 一个虚拟地址分成两个部分，一部分存储页面号(前4位，其中3位用于定位索引，1位为bool类型，用于判断页表是否在内存中)，一部分存储偏移量(后12位)。
  
  ![table](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/table.png)
  
## 页面置换算法

  1. 最佳算法：选择的被换出的页面将是最长时间内不再被访问
  
  2. LRU：需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头
  
  3. NRU：
    - 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：
    - 1.R=0，M=0
    - 2.R=0，M=1
    - 3.R=1，M=0
    - 4.R=1，M=1
    - 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。
    
  4. FIFO：选择换出的页面是最先进入的页面。
  
  5. 第二次机会算法：
  
    当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。
    
    如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。
    
  6.clock：第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。
  
## 临界区

  每个进程访问临界资源的那段程序代码称为临界区

  注意：临界区是进程的一段代码，有n个进程就会有n个临界区。
  
## 分页和分段
  
  分段：段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。
  
  分页：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。
  
  区别：
        
    对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。

    地址空间的维度：分页是一维地址空间，分段是二维的。

    大小是否可以改变：页的大小不可变，段的大小可以动态改变。

    出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。
    
  段页式：结合分段和分页，先分段，在分好的段中分页

## 编译过程

  - 预处理阶段：处理以 # 开头的预处理命令；
  
  - 编译阶段：翻译成汇编文件；
  
  - 汇编阶段：将汇编文件翻译成可重定位目标文件；
  
  - 链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。
  
  ![bianyi](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/bianyi.jpeg)
  
## 目标文件的分类

  1. 可执行目标文件：可以直接在内存中执行；
  
  2. 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
  
  3. 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；
  
## 静态链接

  静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

    1. 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。
    
    2. 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。
    
  缺陷：
  
    1. 当静态库更新时那么整个程序都要重新进行链接；
    
    2. 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。
    
## 动态链接

  在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
  
  在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。
  
  ![dongtaiku](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Resource/dongtaiku.jpeg)
    
    
  
    
