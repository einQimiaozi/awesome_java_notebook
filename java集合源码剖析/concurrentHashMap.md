## 构造

1.sizeCtl用于初始化数组容量，但是并不是数组容量的大小，默认值为0,而数组初始默认大小为16，该值一般在每次该表容量后设置为数组大小的3/4

2.底层使用数组+链表||红黑树，链表和树的相互转换节点数量界限也是7

3.数组长度小于64时有限扩容，大于64时优先转换结构

4.线程安全，并且每个方案都加锁，使用了Collections.synchronizedMap(map)方法创建线程安全的map集合，锁对象为object，线程安全的底层使用了Unsafe方法对硬件进行限制，tabAt和setTabAt方法都使用了Unfase方法

5.注意，数组的初始化是在第一次put操作的时候完成的，不是构造阶段，构造阶段仅初始化sizeCtl

## 重要的静态成员

  - int MOVED = -1    表示有其他线程正在扩容
  - int TREEBIN = - 2    表示当时使用红黑树

## 原理

jdk1.7中：

  - 使用segment采用分段锁技术，把一个大的table分成多个晓得segment，segment数量不变，为16,线程对segment加锁，每个segment中存储hash槽数组，所以默认并发最大是16个线程
  - segment继承自ReentrantLock
  - put的时候使用的是cas
  - 键值对中的value属性使用了volatile修饰，保证线程可见，及时更新
  
jdk1.8中：
  - 加入了新的tableForSize方法，该方法用于将传入的参数转换为最接近的一个2的n次放的数值

## 初始化
  - 1.在初始化阶段，使用sizeCtl保证线程安全，如果sizeCtl小于0,则说明有别的线程在初始化数组(其他线程通过cas将sizeCtl改成-1)
  - 2.sizeCtl等于0的话按照默认值初始化，重新这只sizeCtl
  - 3.sizeCtl大于0则按照sizeCtl的值初始化数组
  
  
## 扩容

和HashMap一样，扩容时保证数组大小为2的n次幂

1.判断自己是否是地一个执行扩容的线程

2.如果不是则帮助扩容

3.如果是则置sizeCtl为一个小于0的数(源码里使用的是位运算)，并执行扩容函数

4.一条线程至少处理16个槽，所以如果当前扩容计算出来的结果少于16,则只用一条线程处理，并且每条线程处理的槽数必须一致

5.初始化nexttab数组，该数组为扩容后的新数组，长度为原来的2倍

6.初始化ForwardingNode，这个对象有两个作用：1是占位，标记当前节点已经转移到新数组，2是查询到当前节点的时候会自动转向到转以后的节点，防止并发下查询阻塞，所以被转移之后的节点要设置为fwd节点

7.开始从后向前遍历整个数组，每个线程每次最多转移16个节点，同样根据7这个界限判断数据结构在nexttab中是否要转换
  
## 添加

put方法是通过调用同putval实现的

  - 1.检查数组是否初始化，如果没有初始化的话先将sizeCtl设置为-1再初始化，如果sizCtl已经是-1,则抛出Thread.yield
  - 2.计算hashcode
  - 3.如果当前hashcode对应的结点为空则直接添加
  - 4.不为空则取出当前节点的hashcode，如果值为-1(MOVED)，说明有其他线程正在对数组进行扩容，当前线程也去帮助扩容
  - 5.如果值不为-1,则使用sync加锁后更新键值对(按照当前数据结构)
  - 6.更新or添加之后计算节点数量，选择转换数据结构or扩容
  
## 查找

计算出hashcode，遍历，如果查到的是fwd则转换到nexttab中查找

