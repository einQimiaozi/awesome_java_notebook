## 前置知识点-红黑树

1.每个节点非红即黑

2.根节点为黑色

3.叶子节点均为黑色

4.红色节点的两个子节点必须都是黑色

5.跟节点到自己所有的叶子节点所经过的路径上的黑色节点数量均一致

6.从某节点出发到其所有的叶子节点，如果路径长度最短为n，那么最长则最多为2n

7.相比avl树：查询性能略差，但添加删除性能更强，因为红黑树不一定左右平衡，所以每次删除和插入时不一定要旋转操作

8.排序依据：如果没有实现comparator，则先比String成员，再比类名，最后比hashcode

## 结构

底层结构使用数组+链表实现，jdk1.8后由数组+链表+红黑树实现

通过hash算法计算key在数组中的hash位置，该位置中存放的是一个链表or树(不同的key经过hash后可能数值相同)，在通过访问链表or树取出对应的value

默认容量为16,每次扩容后容量保持在2^n的数量级，装载因子默认为0.75(这个是干啥的后面说)，默认threshold为0,这个值代表当前hashmap中所能容纳键值对数量的最大值，threshold = 容量 * 装载因子

## 扰动函数(hashcode计算函数 hash(Object key))和定位value

### jdk1.7中

  使用key的hashcode值进行绕动计算出新hash值：20位异或 ^ 14位异或 ^ 7位异或 ^ 4位异或 以上操作使用hashcode右移
  
  定位取模：(n-1)&hash，本质上是取模，这里说一下，HashMap的数组长度必须是2^n，因为只有这样在(n-1)&hash的时候才能起到取模的效果，并且取模可以使得数组中的index分布均匀
    
  直接对key的hashcode取模是不行的，因为直接对hashcode取模可能会造成两个不同的hashcode高位相同，之前的绕动计算其实本质上做的也是高位绕动，将高位和低位打乱
  
jdk1.8中：

  使用key的hashcode值进行绕动计算出新hash值：16位异或 以上操作使用hashcode右移
  
  定位取模：算法和1.7一样，只不过1.7中是使用了indexfor这个函数专门计算，1.8中直接取了数组下标

## 装载因子和threshold

根据柏松分布，装载因子取0.75时，单个hash槽内的元素个数为8的概率小于白万分之一，以下分为三种情况

- 1.槽内元素当前小于7：hash槽内的数据结构转为链表

- 2.槽内元素大于7：hash槽内的数据结构转为红黑树

- 3.槽内元素等于7：如果当前是链表就是链表，当前是红黑树就是红黑树，也就是不动了

理由也很简单，因为链表的查找效率是O(n/2)(跟LinkedList的查找原理一样),红黑树是O(logn)，所以当n=8时，红黑树刚好比链表少一次，更快

## 扩容

1.当键值对达到threshold的时候扩容

2.扩容的时候每次扩容2倍(保证容量始终是2^n)，threshold也扩大2倍

3.扩容后对所有元素重新计算hash

## 添加

1.判断数组是否为空，如果为空先扩容

2.计算key的hash值

3.找到hash槽，如果hash槽为空直接插入

4.如果不为空但是是头节点的话(key和头节点一样)，直接覆盖新的value

5.如果是TreeNode的话则改用红黑树的插入方式，如果key存在则覆盖value，不存在则插入value

6.如果不是TreeNode，则使用链表的遍历方式插入，key存在则覆盖value，不存在则插入value

7.如果插入后链表长度>7并且数组长度>=64则将链表转成红黑树，否则优先对数组进行扩容，注意是数组！！！

8.如果数组长度>threshold，则扩容，在扩容过程中如果遇到hash槽内的节点降到7以下，则降级为链表(扩容会重新计算hash，所以节点有可能减少)

## 总结

线程不安全，有modcount(fail-fast)机制

容易碰到循环引用(?)

允许key和value为null

迭代无序，内部顺序由hash槽(就是那个数组)维护

位运算代替取模

多线程同时扩容会申请多个数组，但是只有一个会被应用

## 和HashTable的区别

1.HashTable默认容量为11,每次扩容2倍+1,不可以使用位运算取模

2.线程安全不同

3.HashTable直接使用hashcode作为hash，不再绕动
  
  
