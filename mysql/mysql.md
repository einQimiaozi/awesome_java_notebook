## Mysql基础架构

![mysql](https://github.com/einQimiaozi/awesome_java_notebook/blob/main/mysql/Resources/mysql.jpg)

存储引擎默认是innoDB

1.连接器：负责客户端和server建立链接，维持，管理连接等
  - 应尽量减少连接动作，使用长链接
  - 长链接造成的OOM和内存占用过大可以通过定期断开重连和执行musql_reset_connection来重置链接资源

2.查询缓存
  - 因为数据表会经常更新，所以查询缓存失效频繁，不建议使用
  - 除非你的业务是一张静态表
  - mysql8.0中查询缓存功能被删除了

3.分析器：一般就是用来检查语法的

4.优化器：一般用来决定选择用哪个索引，决定多表关联下各个表的连接顺序，优化器不影响查询结果，只影响查询效率

5.执行器
  - 1.判断当前用户对要查询的表是否有查询权限
  - 2.有权限就根据表的引擎，使用这个引擎所提供的接口
  - 3.对值的查找和范围判断之类的都在这部分完成，返回结果也通过执行器

## redo log

1.redo log就是WAL(Write Ahead Logging)技术的实现方法，用于解决crash-safe(字面意思)，是innoDB特有的日志

2.sql语句执行的时候会把执行记录写入redo log，本质就是写入内存，等适当的时候一次性写入磁盘，当出现crash-safe的时候可以根据redo log记录的操作进行数据库回滚恢复

3.redo log的结构：
  - 1.大小固定，一组4个文件，每个文件1gb
  - 2.使用write pos指针记录当前位置，write pos边写边向后移动，checkpoint指针记录擦除位置，通俗的说chechpoint-write pos的空间就是当前空着的空间，可以写入
  - 3.redo log采用循环记录的方式，例如4个文件分别是abcd，d文件写完之后会回到a文件开头继续写，当write pos追上checkpoint位置的时候就是写满了，要对文件进行擦除，同时被擦除的部分要写入磁盘

4.物理日志，记录了“某个数据页上修改了什么”

## binlog

1.binlog是所有执行引擎都可以使用的日志

2.并不是循环记录的，而是不断追加写入的，不会覆盖以前的日志

3.逻辑日志，记录了“给id=2这一行的c字段+1”这种东西

4.只能用于归档，没有crash-safe能力

binlog和redo log两种日志一般一起使用，进行两阶段提交，两阶段提交的意思就是：先写入redo log，进入prepare阶段，然后写入binlog，然后让redo log进行commit，如果不进行两阶段提交而是先写一个再写一个的话会导致其中一个日志回复的数据和原库不同

innode_flush_log_at_trx_commit参数控制redo log的commit频率，建议设置为1,这样每次事务的redo log都会写入磁盘

sync_binlog同上

## sql语句的执行过程

1.执行器对语句给出的条件进行查找

2.innoDB查找当前数据页是否在内存中，如果在则返回页中的该行数据，不在就去磁盘里找，读入内存

3.执行器执行事务

4.innoDB将执行结果更新到内存

5.将操作记录写入redo log，让其处于准备阶段

6.将操作记录写入binlog

7.提交事务，并commit redo log

## mysql的数据类型

1.整型
  - 1.tinyint smalliont,meduimint,int
  - 2.bigint(用于记录大数)

2.浮点型
  - 1.float(8字节) double(16字节) 
  - 2.decimal(大数，用于存储货币单位)

3.日期
  - 1.date，time，year
  - 2.timestamp(4字节，1970-2038年) datetime(8字节，一般比timestamp好用)

4.varchar
  - 用于存储可变长字符串，比定长更节省空间
  - 使用varchar(n)指定长度
  - 使用1到2个额外的字节记录字符串长度
  - 由于程度可变，需要update时做额外工作，会影响update效率
  - 适用场景：
    - 字符串列长度大于平均长度
    - 列的更新很少
    - 使用了像utf-8这样复杂的字符集

5.char
  - 定长
  - 适合存储短字符串

## 预读机制

磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，就能够省去后续的磁盘IO，提高效率

## buffer pool

1.为了解决磁盘上磁盘速度和CPU速度不一致的问题，在操作磁盘上的数据时，先将数据加载至内存中，在内存中对数据页进行操作，缓冲池一般也是按页缓存数据

2.innodb_buffer_pool_size:配置缓冲池大小

3.innode_old_blocks_pct:老生代占lru链长度的比例，默认3：7

4.innode_old_blocks_time:老生代停留时间窗口，单位是毫秒，即同时满足被访问和老生代停留时间超过1秒两个条件才会被插入到新生代头部

5.buffer pool的实现原理(特殊的lru)：
  - 将LRU分为两个部分：新生代(new sublist)和老生代(old sublist)
  - 新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；
  - 新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：
  - 如果数据真正被读取（预读成功），才会加入到新生代的头部
  - 如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池

6.为什么不使用传统lru：
  - 1.预读失败：页被提前放进了缓冲池，结果没读
  - 2.缓冲池污染：某个sql语句如果扫描大量数据可能会把缓冲池里的页全顶出去，导致大量热数据被换出，影响mysql性能

7.优化缓冲池污染，思路是：
  - 不让批量扫描的大量数据进入到 new 区
  - 让真正被读取的页，才挪到缓冲池 LRU 的头部
  - 具体实现：加入了一个“old 区停留时间”的机制：在 old 区域的缓存页进行第一次访问时就在它对应的控制块中记录下来这个访问时间，如果后续再次访问的时间与第一次访问的时间在某个时间间隔内（即该缓存页在 old 区的存在时间在某个时间间隔内），那么该页面就不会被从old 区移动到 new 区的头部

## 事务隔离

1.隔离级别：
  - 读未提交：事务提交前其他事务就可以看到
  - 读提交：事务提交后其他事务才能看到
  - 可重复读：一个事务执行开启阶段会创建一个当前数据状态的静态视图，执行过程中所有的数据都以这个静态视图为准
  - 串行化：对读写进行加锁，防止多线程访问临界资源

2.使用场景：
  - 可重复读隔离级别常用于银行账户月底账单明细校对，这样在校对数据事务执行过程中余额发生了变化也以校对数据事务执行初始创建的那张静态视图为准 

3.实现原理：
  - 使用回滚日志(undo log)和read-view实现

4.undo log：
  - 每个回归日志对应一个read-view，保存的就是执行的操作，比如将2改成1之类的
  - 回滚日志在当前系统里没有比这个日志更早的read-view时就删除了

5.MVCC:mvcc本质上就是由undo log实现的可重复读
  - mvcc是什么：多版本并发控制，是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，维持一个数据的多个版本，使得读写操作没有冲突
  - 当前读：抽象概念，就是读取的时候加锁，读取当前最新的数据并且保证其他线程不能修改，悲观锁
  - 快照读：抽象概念，就是除了串行化以外的其他隔离级别下读取，读到的不一定是最新数据，不用加锁，mvcc要做的就是快照读而不是当前读
  - mvcc的具体实现：除了上面说到的undo log，还有另外两种实现方法
    - 3个隐式字段：每行数据多记录三个字段
    - DB_TRX_ID：6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID
    - DB_ROLL_PTR：7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）
    - DB_ROW_ID：6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引(主键索引)
    - Read View的实现：
      - innoDB中每个事务有一个唯一id，transaction id，每行数据也有多个版本，每个版本有个事务id叫row trx_id,也就是说一行记录其实有多个版本
      - 实际上视图中记录的内容你可以理解为：某一行数据的n个版本，每个版本被transaction id为xx的事务更新，因此这个版本的row trx_id也为xx
      - 而实际上视图中的多个版本并不真正的存在，而是依靠undo log记录的操作回滚倒推出来的
      - 因此一个事务只要在启动的时候保证只认自己启动时刻和之前的生成就可以保证可重复读了
      - 具体的做法是：使用一个视图数组记录事务，数组分为三块，如下图
      - 其中已提交事务的部分可见，未开始事务的部分不可见，未提交事务的部分根据当前事务的row trx_id判断，如果id在这个部分的数组里，则说明没提交，不可见，否则说明提交了，可见
    
      



